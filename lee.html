<html>
<title>SANS Notes</title>
<meta charset="windows-1252">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="w3.css">
<link rel="stylesheet" href="w3-theme-black.css">
<link rel="stylesheet" href="roboto.css">
<link rel="stylesheet" href="font-awesome.min.css">


<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 350px;
  top: 35px;
  bottom: 0;
  height: inherit;
  text-align: justify;}
</style>

<body>

<!-- Topbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-small">
    <a class="w3-bar-item w3-theme-l1"><i class="fa fa-bars"></i></a>
  </div>
</div>

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-small w3-theme-l5" id="mySidebar">
  <a class="w3-button w3-hover-black" href="cole.html">SEC 401 - Security Essentials, Cole</a>
  <a class="w3-button w3-hover-black" href="beaupre.html">SEC 460 - Threat/Vulnerability Management, Beaupre</a>
  <a class="w3-button w3-hover-black" href="cole2.html">SEC 501 - Enterprise Defender, Cole</a>
  <a class="w3-button w3-hover-black" href="brenton.html">SEC 502 - Perimeter Protection, Brenton</a>
  <a class="w3-button w3-hover-black" href="novak.html">SEC 503 - Intrusion Detection, Novak</a>
  <a class="w3-button w3-hover-black" href="strand.html">SEC 504 - Hacker Tools, Strand</a>
  <a class="w3-button w3-hover-black" href="pomeranz.html">SEC 506 - Linux/Unix Security, Pomeranz</a>
  <a class="w3-button w3-hover-black" href="hoelzer.html">SEC 507 - Auditing Networks, Hoelzer</a>
  <a class="w3-button w3-hover-black" href="misenar.html">SEC 511 - Continuous Monitoring, Misenar</a>
  <a class="w3-button w3-hover-black" href="skoudis.html">SEC 517 - Cutting Edge Hacking Techniques, Skoudis</a>
  <a class="w3-button w3-hover-black" href="strand2.html">SEC 550 - Offensive Countermeasures, Strand</a>
  <a class="w3-button w3-hover-black" href="henderson.html">SEC 555 - SIEM with Tactical Analytics, Henderson</a>
  <a class="w3-button w3-hover-black" href="skoudis2.html">SEC 560 - Network Penetration Testing, Skoudis</a>
  <a class="w3-button w3-hover-black" href="wright.html">SEC 561 - Hands-On Hacking Techniques, Wright</a>
  <a class="w3-button w3-hover-black" href="vest.html">SEC 564 - Red Team Operations, Vest</a>
  <a class="w3-button w3-hover-black" href="tarala.html">SEC 566 - Implementing Critical Security Controls, Tarala</a>
  <a class="w3-button w3-hover-black" href="baggett.html">SEC 573 - Automating InfoSec with Python, Baggett</a>
  <a class="w3-button w3-hover-black" href="buggenhout.html">SEC 599 - Defeating Advanced Adversaries, Buggenhout</a>
  <a class="w3-button w3-hover-black" href="wright2.html">SEC 617 - Wireless Ethical Hacking, Wright</a>
  <a class="w3-button w3-hover-black" href="searle.html">SEC 642 - Web App Penetration Testing, Searle</a>
  <a class="w3-button w3-hover-black" href="sims.html">SEC 660 - Advanced Penetration Testing, Sims</a>
  <a class="w3-button w3-hover-black" href="sims2.html">SEC 760 - Advanced Exploit Development, Sims</a>
  <a class="w3-button w3-hover-black" href="lee.html">FOR 408 - Windows Forensic Analysis, Lee</a>
  <a class="w3-button w3-hover-black" href="lee2.html">FOR 508 - Incident Response Forensics, Lee</a>
  <a class="w3-button w3-hover-black" href="hagen.html">FOR 572 - Advanced Network Forensics, Hagen</a>
  <a class="w3-button w3-hover-black" href="zeltser.html">FOR 610 - Reverse-Engineering Malware, Zeltser</a>
  <a class="w3-button w3-hover-black" href="cole3.html">MGT 414 - CISSP, Cole</a>
</nav>

<div class="w3-main" style="margin-left:350px">
  <div class="w3-row w3-padding-64">
    <div class="w3-twothird w3-container">
      <h2 class="w3-text-teal"></h2>

    <h2>    Windows Forensic Analysis, Robert Lee</h2>
</p>


<p>
    A forensic examiner/analyst should have a solid understanding of the
operating system and the application he is examining. Only by    <strong><mark>understanding the OS and applications</strong></mark> on the system you
    are examining will you understand where to look for evidence of an action.
    Many times, you will find that you will have to conduct tests in your lab
    on applications to find what evidence is created by the application when an
    action is taken, and then go to the hard drive you are analyzing and look
    for that piece of evidence. Evidence of action or activity is created by
    both the user of the computer and the system itself.
</p>
<p>
    <strong><mark>Evidence</strong></mark>
    created by a system action might be an audit log showing default system
    maintenance has run at the default time or file access times being changed
    by an antivirus scan automatically being run. Understanding what kinds of
    evidence are created, how they are created, and why will help you be a
    better examiner.
</p>
<p>
    <strong><mark>Findings</strong></mark>
    are the result of your key word searches or individual items of
significance you find during the course of your examination.    <strong><mark>Analysis</strong></mark> is the act of looking at all the individual
    findings, including the existence or lack thereof of data, as well as
    associated metadata (location of the file, timestamps), and determining
    which actions were taken on the computer that would have caused those
    artefacts to exist. Using this we can determine the who, what, when, where,
    why and how.
</p>
<p>
The forensic examiner/analyst should be a master of    <strong><mark>problem solving</strong></mark> because for each investigation, he should
    be asking himself what crime is being investigated and what actions might a
    user have taken to facilitate that crime. Of those actions, what evidence
    would be created by the user, application, or system when that action was
    taken?
</p>
<p>
    Many <strong><mark>artifacts</strong></mark> you will uncover will help substantiate a
    fact. Multiple artifacts that all substantiate the same fact are much more
    effective at increasing the overall weight of your evidence... There are
    commonly four to six locations on an average Windows system that will point
    to a user's file opening or file creation.
</p>
<p>
    Because incident responders and investigative agencies may not be
    immediately aware of what information is evidence when they arrive on
    scene, the Department of Justice advises incident responders to document
    and preserve as much information as they can. They suggest all incident
    responders be trained so they can collect and preserve as much volatile
    data as possible.
</p>
<p>
    With the increased popularity of encryption programs, pulling the power
    plug has already resulted in investigative agencies having nothing to
    examine. In addition, a growing popular claim from defense attorneys is
    that the system was being controlled by a remote administrative
    utility/Trojan or a virus was causing all the activity. Without the
    collection of volatile data, it becomes much more difficult to defend
    against or refute.
</p>
<p>
    <strong><mark>Volatile data</strong></mark>
    is what is referred to as data that will disappear or be destroyed once the
    computer system is powered off. Typically, this is RAM, but it goes
    further. Volatile data is also current active network connections, running
    applications, open/listening network connections, etc.
</p>
<p>
    Incident responders responding to computer intrusions/hacks have for a long
    time now understood the need for conducting <strong><mark>onsite triage</strong></mark>.
    That is, immediately looking for specific items needed to immediately
    further your investigation. This tactic is now being recognized as
    critically useful in non-intrusion related investigations. Before
    conducting any further activity, you should apply a write block. Triage's
    greatest benefits are the immediate identification of investigative leads.
</p>
<p>
    The second benefit, particularly to responding law enforcement, is the
    ability to immediately confront a suspect and with the benefit of specific
    incriminating information obtained by the triage the likelihood of a
    confession is greatly increased. After a triage, with the write block still
    attached you can initiate your physical or logical image of the drive.
</p>
<p>
    With the increased use of encryption, particularly whole disk encryption
    utilities like Windows Bit locker, PGP and True Crypt, it is more important
now than ever before for incident responders to image RAM and    <strong><mark>collect volatile data</strong></mark> on any powered-on system they
    respond to. While it is the most volatile piece of evidence, it is also one
    of the most valuable.
</p>
<p>
Many Windows systems, particularly laptops, maintain a    <strong><mark>hibernation file</strong></mark> named 'hiberfil.sys.' This file is
    created when the computer is placed into hibernation mode-often by closing
    the lid or selecting hibernate from the start menu.
</p>
<p>
    It turns out that "hiberfil.sys' is a complete copy of everything in RAM
    when that lid was closed! Simply copying this file from the root of the
    system drive gives us a ready-made memory image ready for analysis. Crash
    dump files are also great sources for RAM analysis. Look for "memory.dmp"
    files in the %WINDIR% folder. If a full crash dump was taken, it will be a
    complete copy of RAM.
</p>
<p>
    When you <strong><mark>image memory</strong></mark>, you generally want to avoid
    exporting memory to the host system for a variety of reasons, including
    that you would be overwriting unallocated space with your memory image
    file, (destroying your ability to recover files in that portion of
    unallocated space). It is usually best to export memory to another
    networked machine or your attached sanitized USB device.
</p>
<p>
    One of the most important things you should ever do before powering off a
    system to remove a hard drive is to check to see whether the drive is
    encrypted or not. If there were indications the drive was encrypted, it
    would be advisable to image the drive while it is powered on and live, if
    you power it off, you likely will not be able to recover the keys.
</p>
<p>
    If you perform a live image of a drive due to encryption, you should always
    image the logical drive instead of the physical one. The logical drive is
    seen as unencrypted by the local machine, whereas the physical disk is
    still encrypted at the disk level.
</p>
<p>
    <strong><mark>Data chunks</strong></mark>
    will be in one of two states on the filesystem: used or not used. Each
    chunk of data (cluster or block) is either owned by an existing file or is
    waiting to be used. This is generally referred to as free space. Even
    though the space is free, it does not necessarily mean that it is free of
    data. Files that were deleted on the system could have written to these
    blocks at one point. This space is considered unallocated by the
    filesystem. Even though the space is unallocated, critical evidence can be
    recovered from these blocks despite not being recoverable by ordinary file
    recovery.
</p>
<p>
    If a file is not fully recoverable, a piece of that file may still be
recoverable. That piece of the file is called a    <strong><mark>file fragment</strong></mark>. Windows writes file information in sector
    sized-chunks. If the file is 1280 bytes in length and the cluster size is
    2048, then Windows will write into the first three sectors. Notice that the
    third sector is only partially written; when that occurs, Windows will use
    the null byte \xOO as a filler until the end of the sector, not the
    cluster. Any extra sectors not used in writing data for the file is slack
    space. Slack space could contain data from the previous file that was
    stored at that location.
</p>
<p>
    <strong><mark>NTFS</strong></mark>
    makes use of a log file to track changes to the metadata to track the state
    and integrity of the filesystem at all times and to correct inconsistencies
    causes by system crashes. Other filesystems call this "journaling," and
    NTFS calls it "transaction logging."
</p>
<p>
    NTFS is able to track all the files that have changed on the system via a
    USN Journal or Change Journal. This allows programs like a backup utility
    or virus scanner to know what files are new or changed since they last ran
    when they need to do an incremental pass over the drive. NTFS has
    incredibly robust security controls to prevent users from opening files
    they aren't allowed to, (Of course, that can all be bypassed by mounting
    the drive in Linux, but that is a whole other discussion.)
</p>
<p>
    The <strong><mark>Master File Table (MFT)</strong></mark> is a very structured database
    that tracks all the objects to be saved on an NTFS volume. Every object
    gets a FILE record within the MFT. Each FILE record contains a series of
    Attributes that contain the various data and metadata related to that file.
</p>
<p>
    One of the most important artifacts you will find in a case is being able
    to prove a file came from a USB or downloaded from the internet. One of the
    easier ways to tell comes in the form of an Alternate Date Stream. This
    unique artifact is incredibly important to determining if contraband was
    sourced from a browser, skype, P2P session, or an online application.
</p>
<p>
    Starting with XP SP2, when files are downloaded from the Internet via a
    browser to a NTFS volume, an alternate data stream is added to the file.
    The alternate data stream is named "Zone.Identifier." The Zone.Identifier
    usually has simple text with the stream ZoneID=3." Value 3 means that the
    file was downloaded from the Internet and it's potentially unsafe.
</p>
<p>
    Volume Snapshot Service (or Shadow Copy) is the new "System Restore" for
    VistalWin7 and 2008. Essentially, it is like Time Machine" for MACs. It
    performs a cluster by cluster diffing/backup and stores that information.
    In a nutshell, you can rewind a file, a directory, or even an entire volume
    to a previous state-wonderful for forensics.
</p>
<p>
    <strong><mark>Shadow copy</strong></mark>
    enables a user to essentially revert an entire volume, a folder, or a file
    back in time to a previous version. An investigator can also copy out of
    the Shadow Copy a previous version of the file and examine the differences.
    VSS takes a snapshot only once a day.
</p>
<p>
    The entire volume of C can be backed up to earlier dates. What this would
    mean to a forensic analyst is that if a user wipes a file today, it might
    still be recoverable from the previous snapshot. If an investigator
    examined the shadow volume created from yesterday's snapshot, the file is
    recoverable from that volume. The shadow volume that can be examined is an
    exact duplicate backup of the entire volume including unallocated space.
    How many shadow volumes will an investigator have access to? It depends on
    disk size. Generally, 3-5% of disk space is allocated for the volume
    shadow; however, upwards of 30% of disk space could be utilized.
</p>
<p>
    This capability would be incredibly useful in situations where a bad guy
    might have wiped or overwritten with zeros to the file. You could recover
    it by going back a day or two in the shadow copy volume to retrieve the
    file from allocated space.
</p>
<p>
    Examining Volume Shadow data is made easy with ShadowExplorer.
    ShadowExplorer allows for a user to browse through a familiar Explorer
    folder interface in the VSCs of their choosing. This allows the
    investigator to quickly parse and extract files of interest from the volume
    shadow. In my experience, ShadowExplorer is the perfect tool to attempt to
    extract targeted information from a previous time.
</p>
<p>
    Many discussions about proper acquisition techniques have always discussed
    whether or not to pull the power from a funning system to "freeze' the
    state of the hard drive from accidentally erasing data. For the most part,
    this is a good idea- except when it comes to solid state drives. This
    action could cause some serious problems.
</p>
<p>
    In fact, <strong><mark>cutting the power</strong></mark> could be the worst option for
    trying to ensure proper collection of data on the drive. The repair
    operation could be doing many things, including performing trimming
    operations and wear leveling while the drive is self-repairing after a
    power loss. Some thinking has recommended that the best options might
    include to image the system live.
</p>
<p>
    <strong><mark>Data stream carving</strong></mark>
    is the carving of small fragments and not the entire file. These smaller
    fragments could have great meaning, but usually are part of a larger data
    file or a fragment that could be useful to our case. For example, database
    files such as index.dat files might contain hundreds of websites that have
    been visited When deleted, those URLs embedded inside that index.dat file
    could still be extracted, even if you are unable to recover the entire and
    original index.dat file from your system.
</p>
<p>
    Fragments of data could be extracted from memory, unallocated space, or
    even existing files. An example of extracting deleted data from an
    allocated file would be the registry. Deleted registry keys can still be
    examined and extracted from the registry hives on a system but you need a
    tool to identify and extract those fragments from the registry.
</p>
<p>
The second recover technique is "file carving."    <strong><mark>File carving</strong></mark> is the practice of recovering intact files
    from memory or unallocated space. Generally, the process will scan for
    known file headers at cluster boundaries and carve a file out based on a
    "predicted" length or carving until a known footer of the file is found. A
    file header is a sequence of bytes that are generally unique to each file
    found at the beginning of the file itself. The process is flawed as it
    generally results in many false positives and is difficult to manage
    because there may be hundreds of files recovered.
</p>
<p>
    Office <strong><mark>internal metadata</strong></mark> is a key point of discussion for
    e-discovery cases. This metadata is embedded into the file itself and
    includes information that might be quite useful for a variety of litigation
    reasons.
</p>
<p>
    What kind of metadata might be included in Microsoft Office documents,
    picture files, and link files? In most cases, it is data about the file
    itself. Similar to MP3 metadata (artist, album, rating), metadata includes
    items that have nothing to do with the actual file, except it helps
    describe how the data was created, the location, and the author.
</p>
<p>
    Forensics is probably best known to the average individual for the ability
    of investigators to recover lost or deleted files from a filesystem.
    However, most of the time, the recovery of files is limited to Metadata
    layer extraction. What this means is that a file is recovered by examining
    the file properties such as the starting cluster, the file size, file name,
    and parent directory. On an average system, extracting deleted data is
    easiest using this methodology. The difficulty is that many modem operating
    systems recycle these deleted metadata locations quickly and as a result
    over write the data that is stored there.
</p>
<p>
    A <strong><mark>file header</strong></mark> is how a file usually identifies itself to
    the application trying to interpret the unique data. These common headers
    have key file information that is passed to the application so that the
    application can perform a sanity check to ensure the file is indeed valid.
    When a program is used to scan a filesystem volume looking for these
    headers, it has a good chance at carving the deleted files out of
    unallocated space by carving the file once a header it is looking for is
    found.
</p>
<p>
    Once the file carving begins, the file is carved out until it finds a file
    footer. If a file footer does not exist, then it usually makes a guess as
    to an appropriate file size usually based on similar files. In some cases,
    the file carving tool might be able to scan the header of the file for the
    exact size of the file. Certain files will embed the file size into the
    header itself and this information can be used to accurately extract the
    exact file from unallocated space.
</p>
<p>
    The <strong><mark>registry</strong></mark> is a collection of database files that store
    vital configuration data for the system. It stores software, hardware, and
    system component information. The registry can detail the software that has
    been installed, system configuration, recently used files, and startup
    programs.
</p>
<p>
    The registry can be accessed either on a live system or offline. If
    offline, you will need to know where the registry files are stored. The
    majority of the files are stored under the \%WINDIR%\systern32\config
    directory. These registry hives are DEFAULT, SAM, SECURITY, SOFTWARE, and
    SYSTEM. The files correspond to their meaning in the registry.
</p>
<p>
    The registry can be used to enumerate the most recently used files. It can
    also show you the last files that he searched for on the hard drive, It can
    also show the last typed URLs that he inputted into his browser windows. It
    can also show the last commands executed on the system as well as the files
    that were opened. You can also witness which files were last saved to the
    Windows system.
</p>
<p>
    Similar to file systems, <strong><mark>registry hives</strong></mark> have free and
    allocated areas of data. When a registry key is deleted, the key is simply
    unallocated similar to a file and this makes it recoverable using forensic
    tools on the market.
</p>
<p>
    There are many reasons as to why an individual would want to recover
    deleted keys. In many instances, deleted keys are the result of using
    privacy cleaners, uninstalling programs, and clearing browser history. Many
    artifacts that are extremely useful to case data might be found in deleted
    registry keys as more advanced users will begin to attempt to cover their
    tracks on an average Windows Operating System.
</p>
<p>
The first place we are going to look for information is the SAM. The    <strong><mark>SAM hive</strong></mark> will help us enumerate all the users that have a
    profile on the machine. If your machine is a part of a domain, the SAM file
    containing the user profiles will be located on the Domain Controller.
</p>
<p>
    For a forensic investigator, there are several things we are looking for
    here: 1) Tying a username to a RID (Relative Identifier): There are many
    artifacts on a Windows machine that point back to a user's RID and not his
    username. It is important to document the usemame and the corresponding RID
    for later purposes. This is a very important step. 2) Profiling the user:
    It is incredibly important to profile a user of a machine based on his
    login habits and mistakes. You can easily see the last login of each user
    and the total number of logins that this user has made.
</p>
<p>
    One of the most frustrating parts of many DFIR tools is the accidental
    misinterpretation of data. One of the biggest ones in the digital forensics
    world happens to be whether or not a password is required to log in to a
    specific account. This one fact could change the details of many cases. How
    did the user obtain the password? If a password was not required, how could
    you be sure that the actions are tied to a specific user.
</p>
<p>
    SAM Inside is a password-recovery program for cracking LM and NTLM
    passwords. Although we can use it to crack passwords, we can also check to
    see whether password fields are empty. SAMInside can be pointed to any
    specific SAM and SYSTEM hive files and tell you whether there are passwords
    set for an account.
</p>
<p>
    It is HIGHLY recommended that you set your local analysis machine time to
    UTC to avoid any bias that could be added accidentally from a forensic tool
    and potentially lead to the misinterpretation of time related data in your
    case. You can always refactor the local time in your report later, but UTC
    provides an easy format to perform analysis in and reduce exposure to
    conversion errors or misinterpretation.
</p>
<p>
    If the last access timestamp is turned off, we will not be able to see when
    file data was last accessed by the system. Without the last access time, it
    might be more difficult to tell when programs were last opened by the user,
    such as pictures being viewed, MP3s being played, or Office documents and
    PDFs being examined.
</p>
<p>
    One of the more interesting investigative strategies you can accomplish
    with the MAC Address and SSID of the wireless network you have uncovered is
    to to pinpoint the Geo-Location of the access point used for the
    connection. Being able to discover and pinpoint the exact location and time
    of where and when a specific computer or device was could be incredibly
    important to your case.
</p>
<p>
    Not only will the operating system keep track of the user's last documents
    saved, the Microsoft Office product will as well. Each version of Office
    will keep a list of all the files opened in a specific program. The
    location is always in a key called fiIeMRU. In this key will list many of
    the recent documents, spreadsheets, and PowerPoint presentations that the
    user has opened.
</p>
<p>
    The Windows Shell enables a user to have shortcut (aka link or Ink) files.
    A shortcut file is a file that has information used to access another file
    (or shell object). It is a form of a pointer. There is an abundant amount
    of useful information inside of <strong><mark>lnk files</strong></mark>. Some of the
    more useful information includes the type of drive the target file/object
    is on (a fixed drive, removable, remote, and more). Also included is the
    full path of the target file, including drive letters, volume labels, and
    Serial Numbers for locally attached volumes. for remote volumes (shares)
    the full server shares a path and a drive letter (if the share were
    mounted).
</p>
<p>
    Shortcut files are often useful in identifying files that no longer exist
    on a local machine. They might have been wiped or deleted, but often the
    shortcut file remains and provides an important clue that a file used to
    exist at that point.
</p>
<p>
    The <strong><mark>Shellbag</strong></mark> information is extremely useful because it
    can help us track a user through seeing which folders they have recently
    utilized. In some cases, Shellbag info collects information regarding the
    files in the folders that are listed.
</p>
<p>
    &#8226; We can tell what you executed through UserAssist examination.
    &#8226; We can tell what you touched through file/registry and timeline
    analysis. &#8226; We can tell which folders you opened through Shellbag
    analysis.
</p>
<p>
    The purpose of <strong><mark>USB key forensic analysis</strong></mark> is to determine
    if a specific USB device (key, printer, camera, iPod) was plugged in to a
    system. There is quite a bit of information you can map back to a device.
    Each device contains a specific Serial Number even if it is reformatted.
    That information can be used to see if a device was plugged into a specific
    machine or to find a specific device that was used in a crime.
</p>
<p>
    <strong><mark>Mass Storage Class (MSC)</strong></mark>
    is a transfer protocol that allows mounting of a device's storage area as
    removable media and provides direct access to sectors of data for reading
    and writing. The mounting of these devices occurs at the physical level,
    where if one were to open a mounted partition with a hex editor, all areas
    of the file system are available for view.
</p>
<p>
    <strong><mark>Picture Transfer Protocol (PTP)</strong></mark>
    deals only with images, videos, and its associated metadata; it does not
    provide support for transferring other file types such as word documents,
    zip, and so on.
</p>
<p>
    PTP allows only a unidirectional transfer of files, where users can
    download or copy files from the device to the computer or other peripheral
    but does not support uploading or copying files to the device. Mounting of
    these devices in Windows occurs at a logical level, so you cannot see the
    underlying file system structure for these devices.
</p>
<p>
    <strong><mark>Media Transfer Protocol (MTP)</strong></mark>
    was introduced by Microsoft and is an improvement over PTP partly in that
    it supports a variety of file types. This protocol emphasizes the
    importance of metadata associated with media files, just like PTP does with
    images, and is sometimes used by device vendors as a way to implement DRM.
    MTP is somewhat of a misnomer because it is not limited to only media
    files. Any type of file can be transferred to and from MTP-enabled devices.
</p>
<p>
    USB Key Analysis is one of the most talked about areas in computer
    forensics. The forensic analysis is useful because you can track USB
    devices that have been plugged in to a machine. With USB key analysis you
    can &#8226; Identify Vendor, Product, and Version of a USB device plugged
    into a machine. &#8226; Identify a unique USB device plugged into the
    machine. &#8226; Determine the time a device was plugged into the machine.
</p>
<p>
    Depending on the type of investigation and authorization, a wealth of
evidence can be unearthed through the analysis of    <strong><mark>e-mail files</strong></mark>. Recovered e-mail can bring excellent
    corroborating information to an investigation and its informality often
    provides very incriminating evidence. When conducting forensic reviews, and
    particularly in the eDiscovery world, an investigator must be savvy about
    the various locations where e-mail evidence can exist. It is common for a
    user to have e-mail that exists locally on his or her workstation, on the
    company e-mail server, and in multiple webmail accounts.
</p>
<p>
    When conducting e-mail examinations, we focus on answering four questions:
</p>
<p>
    &#8226; Who sent the e-mail? Computers don't generate e-mail autonomously
    and when reviewing e-mails, we will spend a considerable amount of time
    attempting to identify the originator of a message. This isn't always as
    easy as it sounds, particularly taking into account the ease with which
    e-mail communications can be faked. However, we do often have some good
    leads to follow, including the originating e-mail address, the IP address
    of the originating computer, and whatever contextual clues we can pick up
    from the message itself (such as signature block, textual anomalies,
    references, etc.).
</p>
<p>
    &#8226; When was it sent? We can usually determine when a message was sent
    with a high degree of accuracy. The message itself will have a timestamp
    associated with it, but more importantly, we will focus on the mail server
    timestamps that have been added to the message. These are more difficult to
    fake, and we often have logs and some control over at least one of those
    servers in an enterprise environment.
</p>
<p>
    &#8226; Where was it sent from? Determining where a message was sent from
    can be difficult, but we do have some good places to look. If it exists,
    the originating IP address can be very helpful, particularly when paired
    with geo-location databases that can pinpoint the physical location of that
    IP address. Tracking the domains and lP addresses of the various ISPs and
    mail servers referenced in the message header can also allow us to narrow
    down on a location and at a minimum give tis a starting location to issue
    subpoenas for ISP records.
</p>
<p>
    &#8226; Is there relevant content? This is usually where an investigator
    will start. After all, if the message isn't useful to the investigation
    what does it matter where it was sent from7 We see in this section that e
    mail evidence can provide an amazing amount of information, even beyond the
    messages and attachments we will find in e-mail stores. The contact
    information, calendar appointments, and task lists we find during e mail
    examinations can be extremely helpful in tying the case together.
</p>
<p>
    The easiest way to analyze e-mail messages is via manual review. This
    entails using an appropriate e-mail client (or forensic tool) to manually
    read each message. When working with foreign languages, care should be
    taken to use a client that can parse Unicode characters. If you are working
    with a large number of messages, string searches and de-duplication can be
    used as data reduction methods. A keyword list is created, and a forensic
    tool is used to search each message (and sometimes the entire image file)
    for instances of those keywords. Any duplicate emails are removed from the
    review pool. After data reduction is complete, a manual review is conducted
    on any keyword matches.
</p>
<p>
    <strong><mark>E-mail attachments</strong></mark>
    are a key source of information during forensic analysis. The e-mail
    industry estimates that 80% of e-mail data is stored via attachments. Thus,
    you should expect to spend 80% of your analysis time reviewing them.
    Attachments are a leading cause of virus infections, so it is important to
    treat them with care. Scanning attachments for viruses is critical. If the
    attachments have been exported, then a simple scan of the directory is
    sufficient. Otherwise, you can install virus software on your analysis
    machine with the correct e-mail client plug-in.
</p>
<p>
    The <strong><mark>e-mail header</strong></mark> is a required component of every e-mail
    and provides the "envelope" that a message relies upon for getting it to
    the proper destination. The header can be thought of as a transit ticket of
    sorts. It can tell you who made the booking (sender), the destination
    (recipient), the departure date and time (when the message was sent), what
    route the message took (the servers it traveled through), and the arrival
    date and time (last server that received the message).
</p>
<p>
    There is a wealth of information provided by the header, but as
    investigators, we will focus on data that can tie the message to a computer
    system. We do need to be careful because much of the header information can
    be spoofed (faked).
</p>
<p>
    Besides the client-issued values "from:" "To:" "CC:" "BCC:" "Subject" and
    "Date," five additional header values an investigator should focus on are:
</p>
<p>
    &#8226; Message-ID: Provided by the originating mail server and consisting
    of a unique identifier appended to the server name with an @ symbol. It is
    similar to a tracking number for the message and is logged by receiving
    mail servers. A search of mail server logs for the Message-ID will provide
    evidence of the e mail passing through.
</p>
<p>
    &#8226; Received: You can trace the path a message took by reading the
    "Received" entries starting from the bottom-most entry (the originating
    mail server). Each MTA traversed adds a "Received" entry and each entry
    includes the server IP address, server name, date, time, and time zone.
</p>
<p>
    &#8226; X-Mailer: Identifies the e-mail client used to create the e-mail
    message. Its inclusion is optional, and it can be a good indicator of
    whether the e-mail was created locally or via a web-based client.
</p>
<p>
    &#8226; Received-SPF: Sender Policy Framework ($PF) allows organizations to
    identify which mail servers are allowed to send email from your domain. It
    provides an easy means for receiving mail transfer agents to validate the
    sending IP address to the purported domain. The primary purpose is to
    prevent spammers from forging messages from a specific domain.
</p>
<p>
    <strong><mark>DomainKeys Identified Mail (DKIM)</strong></mark>
    information can also be seen in this header and is another mechanism for
    validating the source of a message by allowing the originating domain to
    identify itself via a digital signature. Since the originating mail server
    is legitimate, we can better trust the originating IP address information.
</p>
<p>
    Host-based e-mail stores can be defined as any e-mail archive stored
    locally on a computer, independent of an e mail server. Host-based e-mail
    typically employs an index file that acts as a table of contents and stores
    metadata such as read status, flags, replied/forwarded information, and
    whether the message has been marked for deletion. A separate message store
    houses the e-mail messages themselves. Both files are necessary to
    accurately parse and review e-mail in the e-mail archive.
</p>
<p>
    <strong><mark>Webmail</strong></mark>
    complicates our forensic efforts because there is often no offline archive.
    The lion's share of all webmail exists on the servers run by the service or
    ISP. An exception exists for users who have set up offline e-mail storage
    using the POP or IMAP protocols allowed by some services. In this case, we
    would expect to find mail in the user's e-mail client and the host-based
    e-mail techniques previously discussed could be used to recover and analyze
    it. Barring that, we are often left with recovering webmail fragments using
    traditional computer forensic techniques (such as keyword searching and
    carving) or requesting the preservation and release of e-mail data from the
    ISP using a court order.
</p>
<p>
    E-mail can be in many different locations. The first step is to identify
    what e-mail clients exist (or have existed) on the system and what e-mail
    servers they are connecting to. This usually requires reviewing the folder
    structure of the system as well as reviewing the Windows registry for
    installed applications. Webmail use can be identified through the Internet
    history, cookies, and cached files.
</p>
<p>
    All <strong><mark>mail archives</strong></mark> should be forensically acquired within
    the scope of authority to search. This includes both server archives as
    well as anything stored locally on the system. Because it is common to have
    many different types of e mail collected during an investigation,
    investigators often convert archives to a consistent format (.PST is the
    current favorite) to aid in review and with the dc-duplication process.
</p>
<p>
    Once relevant files are identified, they should be exported out into a
    portable, easy-to-review format. Hash values should be collected for these
    new files because they should be considered evidence. In an eDiscovery
    case, a subset of this collection of files might be those that are
    "produced" to the opposing counsel and will need to be rendered in the
    requested format (TIFF, PDF, and raw).
</p>
<p>
    The <strong><mark>recycle bin</strong></mark> is a very important location on a Windows
    file system to understand: It can help you when accomplishing a forensic
    investigation because every file that is deleted from a Windows recycle bin
    aware program is generally first put in the recycle bin. Generally, files
    that use command-line or third-party software are not placed into the
    recycle bin. The recycle bin is a hidden folder on your system and can be
    accessed from the root directory.
</p>
<p>
    The Recycle.Bin doesn't really mean a file is deleted because it is still
    considered allocated by the filesystem and operating system. To a certain
    extent, if a user forgets to use Shift-Delete to permanently delete a file,
    then the recycling operation is one of the few user-attributable actions
    related to attempted file deletion.
</p>
<p>
    The <strong><mark>System Resource Usage Monitor (SRUM)</strong></mark> is one of the
    newest digital artifacts discovered and can help prove several user actions
    even after execution of counter-forensic programs. A situation in which
    SRUM data could be useful is to document the activity of an employee
    transferring mass amounts of data from the corporate network to his or her
    laptop before leaving the company. SRUM would likely show the significant
    amount of network data inbound to the employee's computer using the Windows
    Explorer application.
</p>
<p>
    Four of the most exciting pieces of information include what applications
    were running on the system during a particular hour, what user account was
    responsible for launching each application, how much network bandwidth was
    sent and received as a result of that application in a particular hour, and
    what network the system was connected to.
</p>
<p>
    <strong><mark>Event logging</strong></mark>
    provides a standard, centralized way for the operating system and
    associated applications to record important software and hardware
    information. Microsoft describes an event as "any significant occurrence in
    the system or in a program that requires users to be notified, or an entry'
    added to a log."
</p>
<p>
    Events are collected and stored by the Event Logging Service. It stores
    events from various sources in a single collection called an event tog.
    Event logs provide historical information that can help illuminate system
    and security problems as well as tracking user actions and system resource
    usage.
</p>
<p>
    Event logs provide a wealth of information that can help an investigator
    piece together relevant actions that occurred on the system. Similar to
    other forensic artifacts, it is helpful to go through the mental exercise
    of determining what questions event log data can help answer. Some of the
    most common are:
</p>
<p>
    &#8226; What Happened? Event logs can be cryptic to the lay user, but they
    are designed to provide very specific information about activities that
    occurred on the system. Items like Event IDs and Event
</p>
<p>
    &#8226; Date/Time? Timestamps are a key part of event logs, providing a
    temporal context for the events. With systems recording thousands of
    events, timestamps can also help the investigator narrow his or her focus.
</p>
<p>
    &#8226; Users Involved? Everything accomplished within Windows is done
    within the context of an account. We can identify references to specific
    users as well as information about Windows operating system activities
    performed via special accounts like System and NetworkService.
</p>
<p>
    &#8226; Systems Involved? In a networked environment, we will very commonly
    find references to systems other than the host because resources are
    accessed remotely.
</p>
<p>
    &#8226; Resources Accessed? The Event Logging Service can be configured to
    store very' granular information regarding the use of various system
    objects. With nearly every resource considered an object, this provides
    very powerful auditing.
</p>
<p>
    &#8226; Security Log: Records events based on auditing criteria provided by
    local or global group policies.
</p>
<p>
    &#8226; System Log: Records events logged by the operating system or its
    components, such as the failure of a service to start during the boot
    cycle.
</p>
<p>
    &#8226; Application Log: Records events logged by applications, such as the
    failure of MS SQL to access a database or an antivirus alert.
</p>
<p>
    Most of the questions we are looking to answer during a forensic
investigation tend towards answers found in the    <strong><mark>Security log</strong></mark>. The System and Application logs store
    information more useful for troubleshooting by system administrators. The
    Security log records an audit event whenever a given system or user action
    meets the criteria set forth by the audit policy in use. They can provide
    details on a variety of actions, including user authentication (logons,
    runas command, remote access, etc.) and what a particular user did on a
    system after authentication.
</p>
<p>
    It is possible to tailor auditing for a specific user account using the
    gpedit.msc snap-in in Windows. Thus, if you suspect a specific account has
    been compromised by an intruder, or you would like more detailed auditing
    on critical accounts like administrators, this tool can provide that
    capability on a per account basis.
</p>
<p>
    Windows installations have never had adequate event logging enabled out of
    the box. Enabling proper logging requires an administrator to modify the
    security audit policies after installation. Workstations are where we
    typically find the least amount of logging. This is particularly true for
    standalone installations. Thus, in the average law enforcement search
    warrant served on a residence, there might be less security logging
    available than in an enterprise.
</p>
<p>
    Tracking account usage is one of the more common uses for reviewing event
    logs. Knowing when a user account logged on to a system and subsequently
    logged off can provide helpful corroborating evidence along with other
    forensic artifacts found. If account credentials are suspected to be
    compromised, reviewing successful logons throughout your network can help
    track where the hacker has been.
</p>
<p>
    When a hacker gains access to a system through some sort of an exploit
    (remote code execution, privilege escalation, service exploitation,
    client-side attacks resulting in backdoors, etc.), there is typically no
    record of "logon" within the event logs. This is intuitive because a
    backchannel is being used and the standard APIs for access are being
    circumvented.
</p>
<p>
    Utilizing event logging to monitor important files, folders, network files
    shares, the registry, and even the SAM database is a powerful feature that
    few administrators take the time to implement. They can give the analyst
    very detailed information about when critical resources are accessed, by
    what user accounts, and what actions were performed on them. With companies
    focusing more on intellectual property theft, you might find yourself lucky
    enough to have these events available during your investigations.
</p>
<p>
    An age-old anti-forensic technique relies upon backdating the system clock
    to manipulate file system timestamps. Need that contract to have been
    signed last week? No problem! Just set your system clock back, copy the
    document to a new volume, and make your modifications! Luckily, this type
    of bad behavior is quite easy to detect using a variety of techniques,
    including file application metadata artifacts. Time manipulation can be
    detected more broadly via event logs.
</p>
<p>
    <strong><mark>Event Log Explorer</strong></mark>
    is a third-party event log management software package that runs circles
    around the built-in Microsoft tools. It provides just about every feature
    that a forensic analyst could want when doing a log review and greatly
    speeds up the process.
</p>
<p>
    It allows many log files to be opened simultaneously and even merged,
    greatly aiding with event correlation and reducing the amount of time
    needed to search. This ability extends to being able to open logs on
    multiple remote systems simultaneously for live reviews. It has a very
    robust filtering capability, including access to the text-based Event
    Description field where so many of our forensic artifacts are located.
</p>
<p>
    <strong><mark>Browser forensics</strong></mark>
    is a critical skill because it can provide an overwhelming amount of
    information to the investigator. Accessing the Internet is one of the most
    frequent user activities, and browsers are the key portal used to
    facilitate that access. In some cases, such as employee misuse, Internet
    activity alone may provide the key pieces of evidence. In other cases,
    Internet activity may not be the focus but can provide valuable
    corroborating evidence.
</p>
<p>
    Although many different browser artifacts exist, three, in particular,
    provide the foundation of most browser evidence: &#8226; History Files
    &#8226; Browser Cache &#8226; Cookies
</p>
<p>
    Evidence from these locations goes a long way toward helping the
    investigator profile a user: determining what sites were visited, how
    often, at what times, and what kinds of activities were performed on that
    site. Although these three artifacts are invaluable, you need to be aware
    that there are ancillary locations that can greatly help us corroborate
    evidence and fill in the picture of what happened on a computer system.
</p>
<p>
    Items such as <strong><mark>bookmarks</strong></mark> can show knowledge and intent of
    the user who chose to save them. The download folder and temporary
    directories often house long forgotten downloads that could be relevant.
    And auto-complete information, although not always easy to get to, can
    provide excellent information on form data entered, search terms, and
    usemames utilized.
</p>
<p>
    From a forensic perspective, all of Chrome's artifacts are nicely stored in
    one location, under the user's profile: Win7+:
    %USERPROFILE%\AppData\Local\Google\Chrome\User Data\Default
</p>
<p>
    The majority of artifacts kept by Chrome are in SQLite databases, making
    them easy to access. That being said, the data stored isn't always in the
    most human-readable form. For example, artifacts like timestamps and page
    transition information often require processing to interpret. For data such
    as preferences, bookmarks, and loaded extensions, the browser uses the
    JavaScript Object Notation (JSON) format.
</p>
<p>
    Of all the browsers covered in this course, <strong><mark>Chrome</strong></mark> stores
    the most metadata about sites visited. The standard URL, page title, and
    referring page information are present. A historical record of each time a
    site was visited is stored in the visits table along with an extra field
    for the last visit time in the urls table. A fairly accurate visit count
    (unlike IE) is recorded along with whether the URL was typed by the user.
    finally, the transition information and visit duration provide much more
    information than other browsers. The latter is a unique feature among
    browsers and could help debunk claims that a site was visited and
    immediately closed after the banned content was identified. It also could
    help identify where users spent most of their time in the browser (on work
    versus nonwork sites for instance).
</p>
<p>
    Chrome and Firefox have implemented robust private browsing options. When
    using private browsing mode, no updates are made to the disk-based
    databases. Instead, all artifacts are kept in-memory and do not get written
    back to the default databases.
</p>
<p>
    Memory analysis will almost certainly pay the biggest dividends when trying
    to piece together private browsing sessions. RAM dumps, hibernation files
    (hiberfil.sys) and the pagefile (pagefile.sys) all provide excellent
    opportunities to recover private browsing artifacts.
</p>
<p>
    In general, modern browsers do a good job of eliminating browser artifacts
    when private browsing modes are enacted. Firefox, Tor, and Chrome barely
    touch the disk in these modes, which means that file recovery techniques
    are not usually successful. Internet Explorer and Edge do write files to
    disk, setting them to delete upon the browser session termination. Thus, it
    is possible to recover some IE/Edge InPrivate disk artifacts using forensic
    techniques. Finally, all browsers are susceptible to analysis of private
    sessions via system memory. RAM, pagefile.sys, and hiberfil.sys may all
    capture private browsing session information, which can be extracted by an
    analyst.
</p>

<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
    if (mySidebar.style.display === 'block') {
        mySidebar.style.display = 'none';
        overlayBg.style.display = "none";
    } else {
        mySidebar.style.display = 'block';
        overlayBg.style.display = "block";
    }
}

// Close the sidebar with the close button
function w3_close() {
    mySidebar.style.display = "none";
    overlayBg.style.display = "none";
}
</script>

</body>
</html>
