<html>
<title>SANS Notes</title>
<meta charset="windows-1252">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="w3.css">
<link rel="stylesheet" href="w3-theme-black.css">
<link rel="stylesheet" href="roboto.css">
<link rel="stylesheet" href="font-awesome.min.css">


<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 350px;
  top: 35px;
  bottom: 0;
  height: inherit;
  text-align: justify;}
</style>

<body>

<!-- Topbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-small">
    <a class="w3-bar-item w3-theme-l1"><i class="fa fa-bars"></i></a>
  </div>
</div>

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-small w3-theme-l5" id="mySidebar">
  <a class="w3-button w3-hover-black" href="cole.html">SEC 401 - Security Essentials, Cole</a>
  <a class="w3-button w3-hover-black" href="beaupre.html">SEC 460 - Threat/Vulnerability Management, Beaupre</a>
  <a class="w3-button w3-hover-black" href="cole2.html">SEC 501 - Enterprise Defender, Cole</a>
  <a class="w3-button w3-hover-black" href="brenton.html">SEC 502 - Perimeter Protection, Brenton</a>
  <a class="w3-button w3-hover-black" href="novak.html">SEC 503 - Intrusion Detection, Novak</a>
  <a class="w3-button w3-hover-black" href="strand.html">SEC 504 - Hacker Tools, Strand</a>
  <a class="w3-button w3-hover-black" href="pomeranz.html">SEC 506 - Linux/Unix Security, Pomeranz</a>
  <a class="w3-button w3-hover-black" href="hoelzer.html">SEC 507 - Auditing Networks, Hoelzer</a>
  <a class="w3-button w3-hover-black" href="misenar.html">SEC 511 - Continuous Monitoring, Misenar</a>
  <a class="w3-button w3-hover-black" href="skoudis.html">SEC 517 - Cutting Edge Hacking Techniques, Skoudis</a>
  <a class="w3-button w3-hover-black" href="strand2.html">SEC 550 - Offensive Countermeasures, Strand</a>
  <a class="w3-button w3-hover-black" href="henderson.html">SEC 555 - SIEM with Tactical Analytics, Henderson</a>
  <a class="w3-button w3-hover-black" href="skoudis2.html">SEC 560 - Network Penetration Testing, Skoudis</a>
  <a class="w3-button w3-hover-black" href="wright.html">SEC 561 - Hands-On Hacking Techniques, Wright</a>
  <a class="w3-button w3-hover-black" href="vest.html">SEC 564 - Red Team Operations, Vest</a>
  <a class="w3-button w3-hover-black" href="tarala.html">SEC 566 - Implementing Critical Security Controls, Tarala</a>
  <a class="w3-button w3-hover-black" href="baggett.html">SEC 573 - Automating InfoSec with Python, Baggett</a>
  <a class="w3-button w3-hover-black" href="buggenhout.html">SEC 599 - Defeating Advanced Adversaries, Buggenhout</a>
  <a class="w3-button w3-hover-black" href="wright2.html">SEC 617 - Wireless Ethical Hacking, Wright</a>
  <a class="w3-button w3-hover-black" href="searle.html">SEC 642 - Web App Penetration Testing, Searle</a>
  <a class="w3-button w3-hover-black" href="sims.html">SEC 660 - Advanced Penetration Testing, Sims</a>
  <a class="w3-button w3-hover-black" href="sims2.html">SEC 760 - Advanced Exploit Development, Sims</a>
  <a class="w3-button w3-hover-black" href="lee.html">FOR 408 - Windows Forensic Analysis, Lee</a>
  <a class="w3-button w3-hover-black" href="lee2.html">FOR 508 - Incident Response Forensics, Lee</a>
  <a class="w3-button w3-hover-black" href="hagen.html">FOR 572 - Advanced Network Forensics, Hagen</a>
  <a class="w3-button w3-hover-black" href="zeltser.html">FOR 610 - Reverse-Engineering Malware, Zeltser</a>
  <a class="w3-button w3-hover-black" href="cole3.html">MGT 414 - CISSP, Cole</a>
</nav>

<div class="w3-main" style="margin-left:350px">
  <div class="w3-row w3-padding-64">
    <div class="w3-twothird w3-container">
      <h2 class="w3-text-teal"></h2>

    <h2>Hacker Tools, Techniques, Exploits, and Incident Handling, John Strand</h2>
</p>
<p>
    <strong><mark>Offense must inform defense</strong></mark>
    . That is, to be a solid defender, you need to understand the attacks your
    systems and networks will face every day. Along with that notion is the
    concept that to be a good attacker (such as a penetration tester or red
    teamer), you need to know the defenses. When offense informs defense,
    security personnel, such as digital forensics experts, can anticipate
    attacker’s moves an and analyze or counter them much more effectively.
</p>
<p>
    <strong><mark>Incident handling</strong></mark>
    is the action or plan for dealing with intrusions, cyber-theft, denial of
    service and other computer security-related events. The scope of incident
    handling is greater than just intrusions; it covers insider crime and
    intentional and unintentional events that cause a loss of availability.
</p>
<p>
    The best way to act on an incident and minimize your chance of a mistake is
by having proper procedures in place.    <strong><mark>Well-documented procedures</strong></mark> ensure that you know what to do
    when an incident occurs and minimize the chances that you will forget
    something.
</p>
<p>
    The steady-state, day-to-day practices of most incident handlers are the
    first two steps: <strong><mark>Preparation and Identification.</strong></mark> We spend
    a lot of our time getting ready to fight the next battle and looking for
    events that could be signs of trouble. The middle of an incident is not a
    good time to ponder your incident-response process, wonder if there is a
    command that will enable you to audit an operating system, or figure out
    how to create a trustworthy forensics image.
</p>
<p>
    It is easy to teach the incident-handling process at a general level. What
    takes persistence and concentration is to hone the skills needed by the
    on-site, at the console, incident handler. Knowing one method of image
    creation is not enough; you need to be ready to move to an alternate
    approach if something goes wrong. Knowing how to read the audit logs and
    investigate a tile system requires knowing the operating system.
</p>
<p>
    How do you detect an incident? The bulk of all detects will come from
    either <strong><mark>sensor platforms</strong></mark> or the things people just happen
    to notice. Sensors include firewalls or intrusion detection systems and
    system logs.
</p>
<p>
    <strong><mark>People</strong></mark>
    can be your eyes and ears, and they are also spread around the
    organization. The trick is to give them the training to know that something
    is wrong and make sure they are aware of the risks and know to whom to
    report.
</p>
<p>
    Ideally, it’s best to deploy two people to handle each incident to gather
    evidence more thoroughly. Therefore, assign a primary handler, and a
    helper.
</p>
<p>
    Our <strong><mark>network perimeter</strong></mark> is monitored by firewalls, routers
    that generate logs, external-facing intrusion detection systems, Intrusion
    Prevention Systems, and other machines on the DMZ. These systems can give
    us earlier warnings about attacks as they monitor our borders with the
    Internet and other external networks.
</p>
<p>
    The next layer down is the <strong><mark>host perimeter</strong></mark>, where we
    monitor activities across each host system’s interface, analyzing what the
    machine is sending out to and receiving from the network. This border can
    be monitored using personal firewalls and host-based Intrusion Prevention
    Systems, local firewalls, and port sentry tools.
</p>
<p>
    The next level of detection is <strong><mark>host-based</strong></mark>, where we
    monitor the actions on the host systems themselves. Antivirus tools, file
    integrity checkers, and endpoint security suites often operate at this
    level, Also, a user noticing strange behavior on her desktop or laptop
    system falls into this category.
</p>
<p>
    The final level is the <strong><mark>application level</strong></mark>, which is
    typically monitored via the logs generated by the application. The
    application may be a web application, a server-side application used by
    thick clients, or even a cloud-based service. Ideally, you want to catch
    the attack at your perimeter, but sometimes (often, in fact), detection
    only occurs at the host or application level.
</p>
<p>
    For network perimeter and host perimeter analysis, when you determine a
    listening port number, you should look up the port to see its official
    assignment, as well as potential malicious use of that port. There are a
    couple of relevant port lists. The official <strong><mark>port list</strong></mark> is
    maintained by IANA, and you may also want to consult a port list for
    commonly used Trojans and or malicious code.
</p>
<p>
    When working through the incident response process, it is often better to
    start with suspicious network connections discovered via the suspect system
    or NetFlow data and work back through the associated services and files.
</p>
<p>
    A lot of today’s <strong><mark>malware</strong></mark> (such as bots, backdoors) are
    activated using a registry key designed to execute programs when the system
    boots up or when a user logs on. A diligent system administrator who
suspects system compromise should check out the values assigned under these    <strong><mark>registry keys</strong></mark>. One of the best tools for reviewing the
    Auto Start Entry Points (ASEs) on a Windows system is autoruns.exe from
    Microsoft.
</p>
<p>
    Administrators also need a good feel for what tasks are normally scheduled
    to run on their systems. The Task Scheduler GUI and the schtasks command
    can be used to list scheduled tasks.
</p>
<p>
    Beyond the built-in capabilities of Windows, some favorite additional tools
    for checking the security status of a machine include the TCPView tool,
    which shows listening TCP and UDP ports, as well as the program name that
    is listening on those ports.
</p>
<p>
    Two other useful process-analysis tools are Process Explorer and Process
    Monitor from Microsoft <strong><mark>Sysinternals</strong></mark>. The Center for
    Internet Security also has hardening templates and scoring tools for
    Windows. They are amazingly useful starting points for hardening Windows
    systems.
</p>
<p>
    One of the most important responsibilities of a senior incident handler is
    to maintain <strong><mark>situational awareness</strong></mark>. What is the effect of
    the vulnerability, can it be remotely exploited, is an exploit available,
    or is this a zero-day attack (an attack that was previously unannounced)?
    These types of questions help the handler come to a reasonable initial
    assessment.
</p>
<p>
    Is a <strong><mark>public exploit</strong></mark> available for the vulnerability? One
    source to check is the Common Vulnerabilities and Exposures page at
    cve.mitre.org, also bugtraq and isc.sans.edu. If there is no mention of a
    public exploit you may be dealing with a <strong><mark>zero-day</strong></mark> (not
    previously announced) vulnerability and exploit. This could be evidence of
    a high-end attacker and raises the stakes.
</p>
<p>
    The goal of <strong><mark>containment</strong></mark> is to keep the problem from
    getting worse. Before we fire, we should take the time to aim! Try to do a
    decent survey and review of the situation before altering the system.
    Containment includes three sub-phases: short-term containment just to stop
    the damage, followed by system back-up, followed by long-term containment
    to make sure the bad guy is denied access.
</p>
<p>
The FIRST organization distributes an    <strong><mark>incident case classification</strong></mark> document that recommends
    characterizing an incident based on three areas: it’s general category, the
    criticality of impacted systems and data, and the sensitivity with which
    information about the case itself should be treated.
</p>
<p>
    From a <strong><mark>category perspective</strong></mark>, most incidents fall into one
    or more areas of the list shown above. It is important to note that a
    single incident may be in multiple categories, such as Compromised
    Information, Malware, External Hacking, and E-mail, all in the same
    incident.
</p>
<p>
    The <strong><mark>criticality rating</strong></mark> of an incident will help determine
    how quickly you’ll need to assign a team and deploy to handle the
    situation. For highly critical incidents, you may want to establish a
    baseline of response time at 60 minutes, or perhaps even less for some
    organizations with critical computing needs.
</p>
<p>
    The <strong><mark>sensitivity metric</strong></mark> here determines the types of
    personnel with whom information about the incident can be shared. For a
    case that is extremely sensitive, we may only want to share information
    with the incident response team and management. For sensitive cases, we may
    add in the system owners and the operations teams. For less sensitive
    cases, we may inform more employees, such as in the case of an isolated
    virus infection.
</p>
<p>
    For <strong><mark>short-term containment</strong></mark>, we just want to stop the
    attacker’s progress, without making any changes to the impacted system
    itself. We want to keep the target machines’ drive image intact until we
    can back it up. Therefore, this short-term containment typically involves
    disconnecting network access and/or power. Containment (both short- and
    long-term) might stop the system from performing various business actions.
    Therefore, make sure you get approval before taking action that will impact
    business. Call the business unit teams before dropping a system.
</p>
<p>
    If you do not make good <strong><mark>forensics</strong></mark> of the system before you
    start doing detailed analysis, you drastically reduce the chance of that
    system information being usable in court. The other attorney could claim
    that you modified the system. If you must do things on the system before
    backing it up, and sometimes this is necessary, try to log each command you
    type and the system’s response.
</p>
<p>
    The initial forensics image in the Containment phase serves as a source for
    forensics analysis. Make sure to get a copy of both memory and the file
    system. You will not be able to make forensics images for all systems in
all incidents. Some incidents may require you to rely on network domain and    <strong><mark>live forensics</strong></mark>.
</p>
<p>
    Make sure to watch out for <strong><mark>trust relationships</strong></mark> concerning
    the affected system. The most important trust relationship is often the
    desktop of the system administrator to the system and to other systems they
    administer. Look over the logs from nearby systems and trusted machines.
    Try to get a feel for how far the bad guy may have penetrated.
</p>
<p>
    For <strong><mark>critical production systems</strong></mark>, extended downtime is
    usually not permissible. In such cases, the incident handlers must stay in
    the Containment phase, performing long-term containment actions on a live
    system to keep it running.
</p>
<p>
    There are several <strong><mark>long-term containment</strong></mark> activities, but
    the most likely, by far, is just patching the system if the attacker
    compromised it by exploiting a vulnerability. Handlers should also patch
    other nearby or similar systems to ensure that they do not get compromised.
    If patching is impractical over the short term, you may want to consider
    deploying an in-line Intrusion Prevention System.
</p>
<p>
    Other long-term containment options that allow us to keep the system in
    production include <strong><mark>null routing</strong></mark>, in which we configure
    routers to drop packets associated with a given source or destination lP
    address used in the attack.
</p>
<p>
    <strong><mark>Firewall rules</strong></mark>
    and router access control lists may need to be tightened to prevent deeper
    attacks as well. Of course, you may need to remove accounts created by the
    bad guy and kill any processes that offer the attacker backdoor access of
    the machine.
</p>
<p>
    Now, we turn our attention to what is probably the hardest problem in
incident handling: Complete and safe total    <strong><mark>removal of any malicious code</strong></mark> and other artifacts left by
    the attacker on the system, such as pirated software, pornography, and
    other illicit data.
</p>
<p>
    There are many cases where handlers have taken systems down and reloaded
    the operating system only to have the box compromised again a few days
later. The best course of action is to determine what the    <strong><mark>cause of the incident</strong></mark> was, to find the vector of
    infection, and take action to prevent this from happening again.
</p>
<p>
    It is also common for an attacker to use common and legitimate services,
    such as SSH and Remote Desktop, to persist and spread. It is incredibly
    important to <strong><mark>monitor the logs</strong></mark> of these services for
    irregularities, like strange source IP addresses and multiple concurrent
    logins from a single user ID.
</p>
<p>
    One of the most important things for incident handlers to do in the
    Recovery phase and in the months following an incident is to check
    regularly to see if the attacker has returned. Most human attackers that
    compromise machines do return to the scene of the crime, making the same or
    similar changes to the system that they made upon initial compromise.
</p>
<p>
    Because of this fact, we urge handlers to write up one or more simple
    scripts that they can run on a daily basis to look for artifacts left by
    the attacker in the previous compromise cycle. If the attacker comes back
    and recreates the same artifacts, your script should detect that fact and
    notify you. We recommend running the script daily or even more often.
</p>
<p>
The only one that really can or will write the <strong><mark>incident</strong></mark>    <strong><mark>report</strong></mark> is the on-site handler. The handler submits the
    draft to the head of the incident-handling team. The chief edits the
    document and interacts with the handler to make sure the document reflects
    what occurred.
</p>
<p>
    When we are working any incident, the first thing our responders ask for is
    the logs for the egress connections from the firewall, the DNS cache or DNS
    logs and, finally, the logs from whatever external web filtering device the
    organization is using.
</p>
<p>
    One of the tactics we use as part of initial incident response is to
    compare the current cache of the DNS server with a list of evil IPs and
    domains by using a tool like dns-blacklists.py. One of our favorite lists
    to compare with is the one from Malware Domain List.
</p>
<p>
    <strong><mark>Espionage</strong></mark>
    is not limited to governments and the military in any way. The focus of
    most espionage is not military; it is economic, and this includes the work
    done by government intelligence agencies.
</p>
<p>
    Businesses routinely are involved in the activities of collecting
    information about their competition or trying to prevent the competition
    from getting information about their activities. As long as this is legal,
    we generally refer to this as competitive intelligence.
</p>
<p>
    A great way to <strong><mark>thumbprint critical files</strong></mark> is to invent an
    acronym that doesn't exist and plant it into the document. Then, if you
    have content-sensing firewalls, intrusion detection systems, or
    network-based Intrusion Prevention Systems, they can be set to look for the
    string.
</p>
<p>
    For incidents involving unauthorized use, the attacker is allowed normal
    access in the course of doing business. However, the attacker abuses this
    access, using it in an unauthorized fashion.
</p>
<p>
The best way to identify insider activity is to gather intelligence through    <strong><mark>proactive scanning</strong></mark> and monitoring. You should always be
    alert for anomalies and keep copious records of those anomalies. These
    records assist you in identifying a threat to the business. Detection of
    anomalies can be accomplished by two means: intelligence gathering on your
    systems and intelligence gathering on your employees' activities.
</p>
<p>
    The goal is to review not only allocated file space, but deleted files,
    slack space, swap space, and so on. Tools such as Expert Witness allow you
    to search the image file for specific file types and character strings.
    This enables you to determine if the suspect had accessed data without
    authorization and provide you insight into what else the suspect may be
    doing. A search for hacking tools, log files, and such helps you identify
    how the suspect is accessing data.
</p>
<p>
    &lt;------------------------&gt;
</p>
<p>
    An <strong><mark>attack</strong></mark> starts with reconnaissance (step I), whereby an
    attacker conducts an open-source investigation to gain information about a
    target. Step 2 is scanning. An attacker uses a variety of mechanisms to
    survey a target to find holes in the target’s defenses. Step 3 involves
    exploiting systems. In this phase, an attacker tries to gain access,
    undermine an application, or deny access to other users. In step 4, the
    attacker maintains access by manipulating the software installed on the
    system to achieve backdoor access. Finally, in step 5, the attackers
    maintain their hard-fought access by covering their tracks. They use a
    variety of techniques to hide from users and system administrators.
</p>
<p>
    One of the big infosec stories of recent times involves attackers learning
    to make money from their activities, ranging from exploiting browser holes
    for grabbing financial data to utilizing worms as vehicles for Denial of
    Service extortion. Indeed, we have seen attackers directly selling to the
    highest bidder customized malicious code to control victim machines or even
    renting out armies of infected systems useful for spam delivery, phishing
    schemes, Denial of Service attacks, or identity theft.
</p>
<p>
    Attackers rifle through <strong><mark>domain name information</strong></mark> for useful
    tidbits in attacking a target. Every time you register a domain name (such
    as sans.org), you provide detailed contact information about your
    organization, including the name, postal address, phone number, and e-mail
    address for your technical, billing, and administrative contact. In
    addition, your registration information includes the IP addresses of your
    authoritative domain name servers.
</p>
<p>
    A <strong><mark>zone transfer</strong></mark> allows an attacker to connect with your
    DNS server and grab all records associated with a particular domain.
    Essentially, zone transfers let an attacker grab a dump of your DNS
    server’s brain.
</p>
<p>
To defend against DNS-style reconnaissance, make sure you    <strong><mark>limit zone transfers</strong></mark>. Your primary’ DNS server should
    allow zone transfers to be initiated by your secondary and tertiary DNS
    servers only. These servers, in turn, should be configured to deny all zone
    transfer requests.
</p>
<p>
    In addition, use <strong><mark>split DNS</strong></mark>. With such an implementation,
    you have two components of your DNS infrastructure: external DNS servers
    and internal DN S servers. Publicly available DNS information is loaded on
    your external DNS servers. Internal names are loaded only on internal DNS
    servers. Also, make sure your DNS servers are hardened. They are among the
    most sensitive components of your infrastructure from a security
    perspective.
</p>
<p>
    Corporate websites often contain contact information with phone numbers,
    which are useful for war dialing and social engineering. Some sites even
    include a description of their computing platforms and/or architecture.
    Attackers grab a copy of your entire website to look for juicy tidbits
    about your organization.
</p>
<p>
    We can also use sites such as namechk to identify which social-networking
    sites a target user account may be using. Currently, namechk checks more
    than 100 social-networking sites to see if a given account is in use. This
    can be used by an attacker to develop <strong><mark>Social Engineering</strong></mark>
    (SE) pretexts.
</p>
<p>
    You should periodically check various open sources of information to see
    what your company is leaking. This analysis can be done by the security
    organization, legal department, and public relations, because all have a
    vested stake in protecting your corporate information.
</p>
<p>
    Pulling information from Google’s cache (and other caches on the Internet)
    is particularly useful for retrieving pages recently removed from a
website. For example, an incident-response team may discover some    <strong><mark>sensitive information leakage</strong></mark> through a website. If it
    removes that page from the site itself, but fails to remove it from the
    Google cache, attackers can still retrieve the page from the cache.
</p>
<p>
    Beyond Google, the Wayback Machine located at www.archive.org has more
    thorough archives, which also include old views of various websites. This
    site features cached pages from billions of web pages for the last several
    years, including multiple views over time of each site.
</p>
<p>
    To defend against these <strong><mark>cyber reconnaissance raids</strong></mark>, check
    your own environment to see what information you are leaking. Check out
    what information you have publicly available on your own websites and think
    about what an attacker could do with that data.
</p>
<p>
    Also, if you find that Google has indexed a URL or cached a page that you
    didn’t want it to, you can use the URL re-crawl request submission form at
    www.google.com/addurl.html. This removes the page the next time the Google
    bot crawls your website, which likely occurs within the next 24 hours.
</p>
<p>
    Even today, an unprotected modern provides the easiest method for
    penetrating a network. Whenever we perform a <strong><mark>war dialing </strong></mark>
    assessment, more often than not, we get into the target network. War
    dialers dial a sequence of telephone numbers attempting to locate modem
    carriers or a secondary dial tone.
</p>
<p>
    Do not rely on <strong><mark>MAC address filtering</strong></mark> at your access point
    to implement security. Although you could allow only traffic from
    registered MAC addresses, such security’ is deeply flawed. MAC addresses
    can be easily spoofed (either by using the ifconfig command in Linux/UNIX
    or with PowerShell’s “Set-NetAdapter” commandlet in Windows).
</p>
<p>
An attacker wants to understand the    <strong><mark>topology of your network</strong></mark>, mainly Internet connectivity:
    DMZ, perimeter networks, and your intranet. The layout of routers and hosts
    can show vulnerabilities or at least let the attacker know where things
    are.
</p>
<p>
    Nmap, the popular network-analysis tool by Fyodor and the Nmap development
    team, can be used for network mapping and port scanning, although most
people associate it with the latter. A common initial step in    <strong><mark>network mapping</strong></mark> is to sweep through the target network
    addresses, sending one or more packets to each address trying to solicit a
    response. The response indicates that the given address is in use by some
    target machine.
</p>
<p>
    The <strong><mark>TTL field</strong></mark> is especially useful in determining how the
    various components of a network are interconnected. The Linux and UNIX
    traceroute command, the Windows tracert command, and Nmap all rely on
    making variations in this field during network mapping to measure the paths
    that packets take across the network.
</p>
<p>
    I’m a fan of <strong><mark>filtering incoming ICMP</strong></mark> messages to anything
    on my network, except perhaps a web or FTP server. All other ICMP coming
    from a hostile network (such as the Internet) can be dropped. You could
    disable outgoing ICMP Time Exceeded messages, but your users couldn’t
    traceroute all the way to you. That might not be a bad thing. Many sites
    are starting to block all incoming and outgoing ICMP messages.
</p>
<p>
    If you notice a particularly frequent <strong><mark>ping sweep</strong></mark> or
    traceroute coming from a single lP address or network, you could filter
    that address in your border router or firewall. If someone is going to
    access your system, ports are the entry points or the doors and windows
    into your system. Therefore, a list of open ports gives an attacker various
    avenue for compromising the system.
</p>
<p>
    In addition to finding out what ports are open on a system, an attacker
    also wants to determine on which platform the system is based. By
    determining the <strong><mark>platform</strong></mark>, an attacker can further research
    the system to determine the particular vulnerabilities it is subject to.
</p>
<p>
    Nmap has a database of how various systems respond to these flags. By
    sending out various packets to both open and closed ports, Nmap can
    determine what type of platform the system is running. This technique is
    called <strong><mark>active OS fingerprinting</strong></mark>, because it is sending
    packets out to measure the response of the machine in an effort to identify
    the OS type. It is active because it sends packets.
</p>
<p>
    When IP packets are sent across a network, at certain points in the network
    (usually at slower links), the packets can be broken up into smaller
    pieces. This process is known as <strong><mark>fragmentation</strong></mark>. Once a
    packet is fragmented, it is not reassembled until it gets to the
    destination. Attackers carefully utilize the techniques to hide what they
    are doing. Packet fragmentation can be used to confuse network-based
    intrusion detection systems (IDS) and Intrusion Prevention Systems (IPS).
</p>
<p>
    <strong><mark>Intrusion detection systems</strong></mark>
    listen in on networks looking for signatures of known attacks. Similar to
    virus detection software, they perform pattern matching. They look for a
    certain pattern and, if they find it, they set off an alarm.
</p>
<p>
    These fragmentation attacks exploit the fact that a network-based IDS and
    packet filters do not have the complete context of how a packet will be
    treated and reassembled at the end system.
</p>
<p>
    The <strong><mark>tiny fragment attack</strong></mark> is designed to fool the IDS by
    creating an initial fragment that is small. It’s so small that no single
    fragment has everything necessary to match a signature. A very stupid IDS
    sensor may allow this type of attack to pass by unnoticed, because it
    doesn’t reassemble the packets. Today, most IDS tools are capable of
    detecting this type of attack. Still, a large number of tiny fragments is a
    burden for the IDS, which has to reassemble the fragments for analysis.
</p>
<p>
A more insidious fragment attack is the    <strong><mark>fragment overlap attack</strong></mark>. In this scenario, the attacker
    creates two fragments for each IP packet. One fragment has the TCP header,
    including a string that is not being looked for. The second fragment has an
    offset value that is a lie. The offset is too small, so that when the
    fragments are reassembled, the second fragment overwrites part of the
    first, particularly the part of the first fragment that includes some data
    that is sensitive.
</p>
<p>
    To avoid these problems, make sure that your systems reassemble packets
before making filtering or intrusion detection decisions. A    <strong><mark>firewall</strong></mark> can do this, imposing its impression of the
    reassembly before the IDS, IPS, and end system get the packet. Everything
    after the firewall has the same interpretation of the packet, because the
    reassembly by the firewall forces the fragments into a single packet.
    Furthermore, a host-based IDS has the local TCP/IP stack and the complete
    context of the end system. Therefore, it can avoid the problems associated
    with fragmentation attacks.
</p>
<p>
    <strong><mark>Vulnerability scanning</strong></mark>
    tools are extremely useful because they automate security checks across a
    large number of systems over the network, However, understand their
    limitations: • The tools only check for vulnerabilities that they know.
    They cannot find vulnerabilities that they don’t understand. • The tools
    tend to be flat: They look for vulnerabilities, but most cannot exploit
    them and pivot beyond an initial surface target to find other targets and
    vulnerabilities. • The tools often don’t perform detailed correlation among
    many vulnerabilities to ascertain overall risk.
</p>
<p>
    An additional scanning technique lets an attacker grab data from a Windows
    environment across Server Message Block (SMB) sessions. This powerful
    technique allows an attacker to grab information about available users,
    groups, shares, and more, all by using a non-admin username and password.
    Microsoft created the <strong><mark>Server Message Block (SMB) protocol</strong></mark>
    to support a variety of network-accessible features of Windows machines,
    including file sharing, printer sharing, domain authentication, remote
    administration (through commands such as reg, se, and many others, as well
    as via enterprise admin GUI tools), and countless other capabilities.
</p>
<p>
    The <strong><mark>Server Service</strong></mark> on Windows implements the service side
    of SMB, making file shares and remote registry’ access available, again
    with many other features. This service is running by default on Windows
    workstations and servers alike. Given all the features supported by SMB, it
    is often subject to attack. On modern Windows machines, SMB is typically
    accessed using TCP port 445.
</p>
<p>
    Typically, you need to allow <strong><mark>SMB sessions</strong></mark> only from
    clients to a specific set of servers (such as file servers and domain
    controllers). Usually, you don’t need clients to establish SMB sessions to
    other clients. Thus, you can implement some solid defenses by configuring
    routers and firewalls to block SMB sessions with TCP port 445, as well as
    the NetBIOS ports TCP and UDP 135 through 139. Allow such traffic only to
    specific systems where there is a business need for SMB.
</p>
<p>
< ------------------------------- >

<p>
One of the more dangerous style attacks we see is    <strong><mark>Border Gateway Protocol Hijacking</strong></mark>. This attack relies on
    an attacker broadcasting an Autonomous System Number which contains a more
    specific route to an IP address or addresses. For example, if I have an ASN
    that is associated with I 00 IP addresses and you have one which just
    broadcasts one the more specific ASN will be the one which gets the
    traffic.
</p>
<p>
    There are a couple of different things an attacker needs to do in order for
this attack to be successful. First, they need access to an    <strong><mark>edge router</strong></mark> on the Internet where they can modify and
    broadcast BGP and ASN information. This means they most likely need to
    compromise an ISP or be a nation-state level attacker. Also, keep in mind,
    these attacks are very hard to detect. The only way to be prepared is to
    have a good idea on how traffic would normally traceroute to your network
    from key locations.
</p>
<p>
    We recommend running and recording what normal <strong><mark>traceroute</strong></mark>
    information looks like by using a service like traceroute.org. Also, user
    awareness training can play a big part in detection. If your users start to
    notice browser error messages and dropped sessions, it may be time to
    investigate.
</p>
<p>
    <strong><mark>Netcat</strong></mark>
    is one of the most useful tools for hacking and cracking available today.
    It allows you to easily move data across a network, functioning much like
    the UNIX “cat” command, where data can be sent over various TCP or UDP
    ports instead of through programs or files.
</p>
<p>
    One of the simplest uses for Netcat is to transfer data between two
    machines. Note that you can create stealthy data transfers by using
    something like UDP port 53, which would look like DNS traffic. Even for
    legitimate uses, it’s often easier to fire up Netcat on some port allowed
    on the network just to move a file around than to actually use FTP.
</p>
<p>
    One of the simplest uses for Netcat is to provide a backdoor login shell.
    By setting up a Netcat listener on any port and activating the e
    (“execute”) option, Netcat runs a shell (or any other program) when someone
    connects on the port.
</p>
<p>
    The <strong><mark>defense against Netcat</strong></mark> depends on the mode in which it
    is used. To summarize, preparation step involves: — Data transfer: Know
    what is running on your systems — Port scanner: Close all unused ports —
    Vulnerability scanner: Apply system patches — Connecting to open ports:
    Close all unused ports — Backdoors: Know what is running on your systems —
    Relays: Carefully architect your network with layered security so an
    attacker cannot relay around your critical-filtering capabilities •
    Intranet firewalls can help create chokepoints for filtering • Private
    VLANs (PVLANs) can also help restrict the flow of traffic between systems
</p>
<p>
    <strong><mark>Sniffers</strong></mark>
    are among the most common of hacker tools. They gather traffic off of the
    network, which an attacker can read in real time or squirrel away in a
    file. Many attacks are discovered only when a sniffer log consumes all
    available file space. To sniff in a switched environment, the attacker
    needs to redirect the flow of traffic on the LAN, either by attacking the
    switch itself or going after the machine sending the traffic.
</p>
<p>
    There is a tremendous amount of focus in the computer underground over ways
    to hack around and through switches. To understand these hacks, you need to
understand how the MAC layer works, particularly the    <strong><mark>Address Resolution Protocol (ARP)</strong></mark>.
</p>
<p>
    Your machine must determine the MAC address corresponding to a given IP
    address. The ARP supports mapping IP addresses to MAC addresses. I send an
    ARP request: What is the MAC address for IP address 10.1.1 .1? The
    appropriate machine sends an ARP response telling me its MAC address. My
    machine then caches this information in its ARP cache, typically for up to
    10 minutes. As with most of these protocols, functionality is built-in, but
    security is not. There’s no way to verify that the ARP response came from
    the proper machine.
</p>
<p>
    By sending ARP responses when no one asks a question, I can flood a
switch’s memory or even poison the victim system’s ARP cache.    <strong><mark>ARP spoof</strong></mark> undermines the Address Resolution Protocol
    (ARP). Arpspoof allows an attacker to inject spurious ARP responses into a
    LAN to redirect all traffic from its intended destination to the attacker
    running a sniffer. Then, if lP forwarding is activated, the packet routes
    through the attacker’s machine and gets forwarded to the true destination.
</p>
<p>
    If the attacker controls the victim’s computer through a drive-by download,
    worm, or bot, the attacker can install his or her own cert on the machine
    in the browser’s store of <strong><mark>trusted certificates</strong></mark>. Given the
    large number of attacker-controlled machines on the Internet, such an
    approach is available to most attackers. We have seen that some malware
    specimens do this to give an attacker long-term control over a victim
    machine. Or an attacker could use social engineering e-mail or pop-up
    messages to trick users into inserting a bogus certificate in their
    browsers.
</p>
<p>
    In the <strong><mark>sslstrip attack</strong></mark>, the client sends an HTTP request,
    as usual. The sslstrip tool passes this request onto the web server. The
    web server attempts to send a redirect telling the browser to go to
    https://www.mybank.com. The sslstrip tool intercepts this redirect in the
    response and tells the browser to continue using http. The attacker then
    uses https to access the site. All traffic from the browser to the attacker
    is cleartext http, and all traffic from the attacker to the website is
    SSL-encrypted https.
</p>
<p>
    <strong><mark>Session hijacking</strong></mark>
    tools are particularly nasty. They allow an attacker to grab an interactive
    login session (for example, telnet, rlogin, ftp, and so on). The victim
    usually notices that his/her session disappears (“Darn network trouble!”).
    The users likely just try to log in again, not knowing that their session
    wasn’t dropped; it was just stolen.
</p>
<p>
    Sessions can be stolen at the originating or destination machines so the
    attackers can bypass all forms of strong authentication and Virtual Private
    Networking. If I take over the session by grabbing the terminal from a
    victim on the originating or destination system, I get access to the data
    before it gets encrypted and sent across the network.
</p>
<p>
    One area of defense that can help on sensitive networks (such as your DMZ)
    involves hard-coding your <strong><mark>ARP tables</strong></mark>. In most systems, you
    can set your ARP tables at system boot to have only specific IP-to-MAC
    address mappings. These values cannot be overwritten by gratuitous ARPs.
</p>
<p>
    Additionally, consider activating <strong><mark>port-level security</strong></mark> on
    your switches. At a minimum, that implies locking down each physical port
    on the switch to a allow only a single MAC address. Going further, you
    could lock down each physical port to allow only a specific MAC address.
    Furthermore, if you encrypt your sessions, the attacker won’t be able to
    hijack them, because he/she won’t have the keys to encrypt or decrypt
    information.
</p>
<p>
    <strong><mark>DNS</strong></mark>
    does recursive queries. When a client wants to connect to a server, it must
    resolve the server’s name. The client’s resolver checks the local files to
    see if it already knows the IP address. If not, the client requests the
    mapping of name to address (in the form of a DNS address record) from the
    local name server (which it locates based on information in UNIX’s
    /etc/resolv.conf or in the Windows network control panel). The local name
    server receives the query. If it has the information cached from a previous
    lookup, it sends a response. If it doesn’t have the information, it does a
    recursive lookup.
</p>
<p>
    <strong><mark>DNS Poisoning Defenses</strong></mark>
    : — Make the source port of DNS queries difficult to predict. That way,
    responses with bad port numbers are rejected — Makes the attack more
    difficult, because bad guy must predict both Query ID number and UDP port —
    Patch your DNS servers — Do not accept piggybacked responses and use a
    hard-to-predict Query ID — Keep DNS server (BIND, Windows DNS, DJB DNS, and
    others) up-to—date — Configure external DNS servers to perform recursive
    queries only for internal systems. — Don’t let just anyone on the Internet
    cause your external DNS server to do recursive look ups
</p>
<p>
    Of course, users must be educated to know that they should only interact
    with a bank over secured connections. Furthermore, just because the lock
    lights up in the lower corner of your browser does not mean you are dealing
    with the actual site you think you are! It just means that you are dealing
    with a site that paid VeriSign their registration fee. Users must be
    educated to check the credentials of the sites they are visiting if
    sensitive business is going on.
</p>
<p>
    After identifying the problem, you need to quickly get rid of the bad DNS
    entries. You can do this by rebooting the DNS server or using a process to
    flush the server’s cache. To get back into business, patch our DNS server
    using the latest version, which is likely less susceptible to this form of
    attack.
</p>
<p>
    <strong><mark>Buffer overflow exploits</strong></mark>
    are one of the most insidious information security problems. A buffet
    overflow essentially takes advantage of applications that do not adequately
    parse input by stuffing too much data into undersized receptacles. The same
    root cause (non-validated input) is also the cause of other attacks, such
    as heap overflows.
</p>
<p>
    <strong><mark>Metasploit</strong></mark>
    . The tool holds a collection of exploits themselves, little snippets of
    code that force a victim machine to execute the attacker’s payload.
    Metasploit has over a thousand different exploits today, including numerous
    common buffer overflow attacks. Next, the tool offers a set of payloads,
    the code the attacker wants to run on the target machine. Some payloads
    create a command-shell listener on a network port, waiting for the attacker
    to connect and get a command prompt. Other payloads give the attacker
    direct control of the victim machine GUI across the network by
    surreptitiously installing VNC, the GUI remote-control tool.
</p>
<p>
    <strong><mark>Buffer Overflow defenses</strong></mark>
    : At a minimum, keep your systems patched Vendors frequently release
    patches for various programs that have buffer overflows A robust patching
    process involves rapidly obtaining, testing, and applying patches Utilize
    host-based IPS that offers buffer overflow protection by — Blocking certain
    calls into the kernel from certain applications — Offering additional
    memory protection to areas like the stack Deploy application white listing
    software
</p>
<p>
    Filter both incoming and outgoing traffic from your site to minimize the
    avenues an attacker has to get in or communicate out. For ‘our outbound
    traffic, utilize proxies wherever possible. They give you a point of
    control and detection.
</p>
<p>
    It is also fairly safe to assume you have been compromised. Because of this
    it is increasingly necessary for us to start hunting for attackers who have
    successfully flown under the radar. <strong><mark>Hunt teaming</strong></mark> is an
    activity where we utilize a number of techniques to bypass traditional
    security technologies as part of our penetration tests to hunt down other
    attackers who may have used similar techniques.
</p>
<p>
    Identifying buffer overflow attacks can be tricky. First, look for unusual
    server crashes. Also, IDS and IPS tools have signatures to look for buffer
    overflow attacks, Finally, look for new accounts on the system. Attackers
    frequently create new accounts when they’ve taken over a machine using a
    buffer overflow.
</p>
<p>
    For
<strong><mark>containment</strong></mark>, you need to quickly harden similar systems on your network. Otherwise,
    the attacker is likely to spread through your network using the exact same
    attack against other systems. For <strong><mark>eradication</strong></mark>
    and recovery, you should rebuild. If an attacker compromises your system
    with root privileges, you will likely have to rebuild it from scratch using
    the original install media and patches.
</p>

<p>
    &lt; ------------------------------------ &gt;
</p>
<p>
    In most organizations, <strong><mark>passwords</strong></mark> are the first and only
    line of defense for protecting information and servers. Because most user
    IDs consist of the first initial and last name of an employee or some
    combination, it is fairly easy to find out valid user IDs for individuals
    at a company. Based on this, the only other piece of information you need
    to gain access is a user password. Therefore, they need to be protected and
    they need to be hard to guess.
</p>
<p>
    To avoid account lockout when performing password guessing, some attackers
employ an alternative means for testing their guessed passwords:    <strong><mark>password spraying.</strong></mark> With this technique, instead of trying
    a large number of passwords for a small number of accounts on a small
    number of targets (traditional password guessing), attackers choose a small
    number of potential passwords to try. They then spray these potential
    password guesses across a large number of account names and machines,
    hoping that one works.
</p>
<p>
    For example, an attacker may start with a list of just four passwords and
    try each for a thousand or more accounts on a dozen different machines.
    Then, after the bad login counter timer expires (resetting the bad login
    count to zero), the attacker might try another four passwords, and so on.
</p>
<p>
The fastest method for cracking passwords is a    <strong><mark>dictionary attack</strong></mark>. This is done by testing all the words
    in a dictionary or word file against the password hashes. When it finds the
    correct password, it displays the result. There are a lot of sites that
    have downloadable dictionaries you can use.
</p>
<p>
    The most powerful cracking method is the <strong><mark>brute force</strong></mark>
    method. This method always recovers the password, no matter how complex. it
    is just a matter of time. Complex passwords that use characters that are
    not directly available on the keyboard may take so much time that it is not
    feasible to crack them on a single machine using today&#8217;s hardware.
    But most complex passwords can be cracked in a matter of days.
</p>
<p>
Following are the main ways to protect against    <strong><mark>password cracking</strong></mark> attacks: &#8226; Get rid of LANMAN
    hashes on local systems. &#8226; Disable LANMAN challenge/response
    authentication across the network, instead forcing network authentication
    to use NTLMv2. &#8226; Have a password policy. &#8226; Implement SYSKEY,
    which provides an extra level of I 28bit encryption of the SAM database
    when it is stored in the registry in the file system. SYSKEY does not
    protect the hashes, however, when they are in memory. Tools such as pwdump,
    fgdump, Cain, and the Meterpreter can pull them from memory, bypassing
    SYSKEY defenses. &#8226; Protect your SAM database.
</p>
<p>
    An attacker can avoid the time-consuming password cracking phase by simply
    grabbing the hashes, loading them into memory, and using them to
    authenticate to a target machine via the Server Message Block (SMB)
    protocol, used for Windows file and print sharing and domain
    authentication, resulting in a <strong><mark>pass-the-hash attack</strong></mark>.
</p>
<p>
    To defend against pass-the-hash attacks, it is vital that enterprises
    maintain control of their hashes. The primary levers you have to manage
    this control is tight host security, making sure you keep your system
    thoroughly patched and hardened to prevent theft of hashes. Furthermore,
    endpoint security suites that bundle antivirus, antispyware, personal
    firewall, and host-based IPS technologies can help shore up the security of
    your end systems. Host-based firewalls on client machines, in particular,
    can help block attackers from using pass-the hash techniques to jump from
    client to client.
</p>
<p>
    <strong><mark>Worms</strong></mark>
    are automated attack tools that spread via networks. A worm hits one
    machine, takes it over, and uses it as a staging ground to scan for and
    conquer other vulnerable systems. When these new targets are under the
    worm&#8217;s control, the voracious spread continues as the worm jumps off
    these new victims to search for additional prey. Using this process, worms
    propagate across a network on an exponential basis.
</p>
<p>
    To evade detection, foil reverse-engineering analysis, and get past
    filters, worm developers are increasingly using polymorphic coding
    techniques in the worms they develop. <strong><mark>Polymorphic programs</strong></mark>
    dynamically change their appearance each time they run, by scrambling their
    software code. Although the new software is made up of entirely different
    instructions, the code still has the same function.
</p>
<p>
    First, harden your systems. A majority of worms and bots utilize buffer
    overflow exploits to compromise their victims. Most operating systems can
    be inoculated against simple stack-based buffer overflow exploits by being
    configured with non-executable stacks. Keep in mind that non-executable
    stacks can break some programs (so test these fixes before implementing
    them) and they do not provide a bullet-proof shield against all buffer
    overflow attacks. Furthermore, patching and host-based IPS can stop other
    buffer overflow exploits.
</p>
<p>
    <strong><mark>Account harvesting</strong></mark>
    is the ability to discern valid useriDs based on how the application
    responds when the user tries to authenticate. This technique is based on
    analyzing what happens when a user types in a useriD and password. If there
    are different error messages that come back (if the useriD is wrong versus
    if the password is wrong), an attacker can determine the useriDs associated
    with the system.
</p>
<p>
    If there are differences in the error message between an incorrect userlD
    and an incorrect password, attackers can use automated harvesting scripts,
    going through the whole possible userlD space to determine valid useriDs.
    So, if a web application sends back one message or error code when the
    userlD is wrong and another message when the password is wrong, an attacker
    can set up a brute force guessing script to harvest all the userlDs. Its
    not glamorous, but it works like a charm for applications that have
    differentiations between the error messages.
</p>
<p>
    How do you defend yourself against this kind of attack? All authentication
    error messages must be consistent. If the useriD is wrong or if the
    password is wrong, the same message should display. Everything should be
    identical: The HTML as well as any information passed back in the URL
    location line of the browser.
</p>
<p>
    In addition, you may want to have individual useriDs tracked for a given
    number of bad logins and presented with an <strong><mark>account lockout</strong></mark>
    message after several invalid login attempts. If users try four or five
    different bad passwords in a row, you could lock out their account, either
    permanently (requiring a call to the help desk) or for potentially just a
    certain amount of time.
</p>
<p>
    Some web applications take input from a user and then process that input by
    launching a command shell to run a program to deal with the input. In a
vulnerable application, an attacker can subvert this process by    <strong><mark>injecting commands</strong></mark> for the shell to run appended to normal
    input. Sometimes, these commands are separated from the input by a; (on
    Linux) or an &amp; (on Windows) to cause the shell to view the trailing,
    attacker-injected command as part of the normal call for the shell to
    execute the program.
</p>
<p>
    Some web applications dispense with launching a shell to invoke the
    program, but instead just execute the program to handle the input, and the
    program can be tricked into further executing the attacker&#8217;s input.
    Either way, we have a command injection vulnerability if the web
    application can be tricked into running commands supplied by the attacker
    as user input.
</p>
<p>
    These attacker commands could arrive via arbitrary forms of user input on a
    web application, including URL variables (passed via HTTP GET), browser
    form variables (passed via IITTP POST), cookies, or other input methods.
</p>
<p>
    When attackers verify that command execution is possible via ping or
    nslookup, they can then move to more elaborate commands. In particular,
    some attackers inject commands causing the target machine to mount a file
    share on an attacker-controlled system. That way, attackers can cause the
    target to execute the bad guys&#8217; code right from the file share,
    without even installing the software on the vulnerable target.
</p>
<p>
    To defend against command-injection attacks, you need to educate your web
    developers to treat user input carefully, avoiding any risky activity that
    may result in its execution, such as launching shells or directly calling
    exec features on inputted data. You should also strive to conduct periodic
    and regular vulnerability assessments and in-depth penetration tests of
    your systems to find such flaws before bad folks do.
</p>
<p>
When attackers can successfully conduct a    <strong><mark>SQL injection attack</strong></mark>, they may retrieve information that
    has not been authorized. They could change account information, updating
    various tables in the database, or perhaps even remove entire datasets,
    such as dropping tables or even doing fine-grained editing of the database.
</p>
<p>
    Attackers try to enter special characters and pieces of a SQL statement
    into their user input to see if they can get them to run on the backend
    system. The attacker types these components directly into the web
    application to see if it is carried back to the backend database.
</p>
<p>
    In addition to the single quotes and double quotes, may try to enter in
    many different other characters to see if they can get the backend database
    to send some information in return. They may try semicolons or asterisks,
    percents or underscores, or even individual elements of SQL syntax.
</p>
<p>
One level of defense against SQL Injection involves    <strong><mark>limiting permissions</strong></mark> of the web application when accessing
    the database. Don&#8217;t let your web app have admin capabilities on your
    database! That&#8217;s incredibly dangerous. Clamping down on these
    permissions won&#8217;t eliminate SQL Injection, but it can limit the
    attacker&#8217;s ability to explore the database fully.
</p>
<p>
    Also, consider using <strong><mark>parameterized stored procedures</strong></mark>. This
    technique splits up user input into individual parameters, which are fed as
    isolated elements into stored procedures running on the database. Because
    the user input is split among various parameters, SQL Injection attacks
    become far more difficult for the attacker.
</p>
<p>
    Further bolstering your defenses, you need to build your web applications
    so that the server side screens out any extraneous but potentially
    meaningful user input. You need to filter out minus signs, semicolons,
    asterisks, percentage signs, underscores, or any other shell
    metacharacters, such as ampersands, pipes, or question marks.
</p>
<p>
    <strong><mark>Cross-Site Scripting</strong></mark>
    enables an attacker to steal information (such as cookies) from users of a
    vulnerable website. So, if your online bank is vulnerable, we might steal
    your banking cookies. Cross-Site Scripting involves sending scripting code
    (usually JavaScript or VBScript) to a web application that sends data back
    to the browser. The web server has an application that reflects user input
    back to a web bro set. When the code gets to the browser, it is executed.
    Upon reaching a browser, the script on this page pops up a dialogue box.
    SQL Injection goes after a backend database. XSS goes after other
    users&#8217; frontend browsers. Still, by filtering out the offending
    characters at the web app, we can protect both the backend and the
    frontend.
</p>
<p>
    To defend browsers and other clients that process browser scripts, you
    could disable scripting support in the client configuration. However,
    turning off all scripting support for languages such as JavaScript can
    break many websites, which may be important to users. Another option is to
    use a <strong><mark>script filter</strong></mark>, which can allow scripts from some
    sites and block them from others, or alternatively, prompt a user when a
    suspicious browser script is encountered.
</p>
<p>
    Defenders can use proxy tools to help defend against these attacks,
monitoring all inbound traffic destined for their websites using    <strong><mark>Web Application Firewalls </strong></mark>(WAFs). These tools sit in front
    of a web server and look for incoming requests where an attacker
    manipulated a cookie or other state element that is supposed to remain
    static. They also look for other suspicious behavior, such as input that
    contains SQL Injection or XSS attacks.
</p>
<p>
    A <strong><mark>denial-of-service</strong></mark> attack involves an attacker preventing
    legitimate users from accessing a service. They are affectionately referred
    to as DoS attacks. The attacker is focused on stopping legitimate access;
    technical finesse is not paramount. Although many denial-of-service attacks
    may not be technically elegant, they can be a big problem.
</p>
<p>
    You need to keep your systems patched because many DoS attacks target old
    versions of vulnerable systems. In addition, you need to make sure that you
    have adequate bandwidth and redundant paths to your critical systems. It is
    trivially easy for a script kiddie to completely exhaust a Tl line.
</p>
<p>
    Generally speaking, there are two categories of DoS attacks: local DoS and
    network-based DoS. <strong><mark>Local DoS attacks</strong></mark> are run from an
    account on the victim machine. An attacker runs some program or function
    locally that prevents users from accessing their resources. There are two
    ways to execute local DoS. The attacker could simply crash a service by
    stopping a process from running. Another way to launch a local DoS attack
    is to tie up system resources.
</p>
<p>
    The second category of DoS attacks are network-based. These attacks are
launched across a network. Within the arena of    <strong><mark>network-based DoS attacks</strong></mark>, we have two types: a malformed
packet attack and a packet flood. A    <strong><mark>malformed packet attack</strong></mark> involves sending a single packet
    or a small stream of packets to a system that are formed in a way&#8217;
    not anticipated by the developers of the target machine.
</p>
<p>
The second type of network-based DoS attack is the    <strong><mark>packet flood</strong></mark>. Indeed, this is the most common type of DoS
    today. It is so popular because the attack can be launched remotely,
    allowing the attacker to have distance between him and the victim. Packet
    floods involve sending more packets to a machine than it can handle. The
    attacker either causes all available processing power of the target machine
    to be tied up or even exhausts all bandwidth of the connection to the
    target.
</p>
<p>
    <strong><mark>DNS amplification attacks</strong></mark>
    involve using spooled packets against a third party to amplify traffic to a
    target. These attacks, which have been known about for almost a decade,
    involve sending small, spoofed DNS queries to a series of DNS servers on
    the Internet. The DNS servers send a larger response back to the address
    that appeared to make the request. This results in an amplification of
    traffic directed to the ultimate flood target.
</p>
<p>
    Instead of using a single machine or a small number of machines to launch a
    packet flood, an attacker could turn to a large number of systems,
particularly a botnet, to launch a flood, resulting in a    <strong><mark>Distributed Denial of Service (DDoS) attack</strong></mark>.
</p>
<p>
    You should deploy egress anti-spoof filters at your border routers. These
    filters drop all outgoing packets that have a source address that is not
    located on your network. All packets leaving your network should have a
    source address associated with your network. If they don&#8217;t, either
    something is misconfigured, or an attacker is launching spoofed packets.
</p>
<p>
    To defend against attacks that have a small number of zombies, you should
    make sure you have adequate bandwidth and redundancy. A handful of zombies
    can consume only so much bandwidth. If you have more bandwidth, you can
    avoid losing all your link capacity to an attack.
</p>
<p>
    If the flood is significant, you need to call your ISP&#8217;s incident
    response team immediately and ask it to start implementing filters on its
    network. By blocking the attack at the next level upstream, your ISPs can
    defend you from much of the brunt of the flood. Although this is a reactive
    solution, it is the only practical means of surviving during a DDoS attack
    that involves a huge number of zombies.
</p>
<p>
    &lt; ----------------- &gt;
</p>
<p>
    Numerous attackers, once they gain access, want to keep access and will use
backdoors and Trojan Horses to accomplish this technique. A    <strong><mark>backdoor</strong></mark> is a program that allows an attacker to bypass
    normal security controls on a system. The normal users of a system might
    have to type in a useriD and a password. A backdoor can allow an attacker
    to get around that, so he doesn&#8217;t have to provide a useriD and
    password. A <strong><mark>trojan horse</strong></mark> is a separate concept from a
    backdoor. A Trojan horse is a program that looks like it has some useful
    function but is actually sinister. It has some hidden capability used by
    the attacker.
</p>
<p>
    Application-level Trojan Horse backdoors involve installing an extra
    application on the target system without changing the operating system
    itself. Bots fall into this category, as does VNC (when abused as a
    backdoor) and Poison Ivy. <strong><mark>User-mode rootkits</strong></mark> go to a
    deeper level by modifying the existing user-mode operating system programs
    on the target machine so that an attacker can maintain backdoor control of
    the machine while hiding. Examples include the Linux rootkit family (LRK),
    the AFX Windows rootkit, and more.
</p>
<p>
    <strong><mark>Kernel-mode rootkits</strong></mark>
    are even more insidious, modifying the heart of the operating system, the
    kernel itself, to achieve very powerful and subtle control of the target.
    Examples of kernel-mode rootkits include the Windows FUto and Linux
    SuperUser Control Kit.
</p>
<p>
    Like many of these remote-control backdoor tools, Poison Ivy requires its
    user to first configure the server, setting up the communication method,
    file name, and various features that will be used. This configuration
    creates an executable suitable for installation of the server on the
    target. After the executable is run on the target, the attacker runs a
    client GUI to control the server across the network.
</p>
<p>
    <strong><mark>Wrappers</strong></mark>
    take two inputs and have one output. The two inputs are programs that the
    wrapper will meld together into the single output executable. An attacker
    will take one executable program such as a game or perhaps a word
    processing program, and wrap nc.exe into that program. The resulting output
    executable can be given a name like the original host program. Attackers
    frequently take innocuous-looking programs and wrap backdoor Trojan Horse
    tools into them.
</p>
<p>
    Trojan Horse backdoor tools leave an enormous amount of information in
    memory for an incident handler to analyze. The handler can dump memory from
    the machine using a large number of tools, including the MemoryDD.bat
    script that is part of Mandiant&#8217;s free Memoryze suite.
</p>
<p>
    After a <strong><mark>memory dump</strong></mark> is created, you can move it off a
    machine using Netcat file transfer or copying it to an 5MB file share.
    Then, the memory capture can be analyzed using various tools. In the past
    few years, numerous high-quality tools have been released for analyzing
    memory dumps from Windows systems. Volatile Systems offers the free,
    open-source Volatility Framework, an excellent tool that can pull an
    enormous amount of information from Windows dumps, including network
    connections, running processes, loaded drivers, etc. Google&#8217;s Rekall
    framework is also outstanding. It has many of the same features as
    Volatility.
</p>
<p>
    Contrary to what their name implies, <strong><mark>rootkits</strong></mark> do not allow
    an attacker to gain root access. Rootkits depend on the attackers already
    having root access, which was likely gotten with a root exploit (such as a
    buffer overflow or other type of attack).
</p>
<p>
    Although rootkits do not let an attacker gain root access, they do allow
    attackers to <strong><mark>maintain root access</strong></mark> once they&#8217;ve
    gotten it. Rootkits let an attacker place a backdoor onto the system to
    maintain control of the machine. Some rootkits also include capabilities
    for gathering information from the local network through sniffing. One of
    the most significant areas in rootkit tools involves masking the
    attacker&#8217;s presence on the system. Rootkits hide logins, programs,
    files, and processes from a system administrator.
</p>
<p>
    To accomplish these goals, rootkits alter the existing operating system on
    the victim machine. Rather than adding a new application to the system like
    we saw with application-level Trojan Horse backdoors, rootkits alter the
    existing programs on the machine. Because they modify existing programs,
    rootkits are classic examples of Trojan Horse backdoors.
</p>
<p>
    For <strong><mark>process hiding</strong></mark>, common Linux rootkits include a
    replacement or redirection for ps, top, and pidof. These tools will not
    show the attackers processes running on the box. In addition, many rootkits
    replace killall so that the attacker&#8217;s processes cannot be killed
    using this command.
</p>
<p>
    Files are hidden by changing the Is and find commands so that they do not
    display the attacker&#8217;s files. The du command is changed so that it
    omits the attacker&#8217;s file from its disk usage calculation. finally,
    the attackers modify syslogd so that it will not record log events
    associated with the attacker&#8217;s machine and/or accounts on the victim
    box.
</p>
<p>
    Attackers use a technique called &#8220;<strong><mark>DLL injection</strong></mark>
    &#8221; to force an unsuspecting running EXE process to accept a DCL that
    it never requested. Very rudely, an attacker injects code in the form of a
    DCL directly into the victim EXE process&#8217;s memory space.
</p>
<p>
    So, attackers can inject code into any running process. Which processes
    lend themselves to rootkit-style attack? One particularly interesting
    target is the explorer.exe process. This process implements the Windows GUI
    that you probably stare into day in and day out. It&#8217;s always running,
    as long as the Windows machine is displaying a GUI.
</p>
<p>
    One way to detect the presence of a rootkit is to compare the output of the
    Is program with the output from &#8220;echo *&#8220; The output should
    include the same files &#8220;echo *&#8220; tells the shell to show the
    contents of the directory. &#8220;echo &#8216;&#8220; is usually not
    Trojaned with a rootkit. Therefore, if the unaltered &#8220;echo *&#8220;
    output differs from the &#8220;Is - Ia&#8221; command, you should be
    suspicious. Numerous tools are available that can analyze Ibm/login to
    determine if a rootkit is installed. Tools like chkrootkit (available at
    www.chkrootkit.org) or many host-based Intrusion Detection tools can detect
    rootkit bin/login programs.
</p>
<p>
    The best way to defend against rootkits is to be proactive. You should use
    a <strong><mark>file system integrity checking</strong></mark> tool. Such tools can
    create a read-only database of cryptographic hashes for critical system
    files. You should store this file offline and periodically check your
    running system to verify the integrity of its files. By using
    cryptographically strong hashes to create digital fingerprints of your
    sensitive files, and periodically checking your existing files against
    those fingerprints, you can detect a rootkit quickly.
</p>
<p>
    When a rootkit is detected, you should completely wipe and reformat the
    drive, reinstall all operating system components and applications, and then
    thoroughly patch the machine. Restore data from a recent backup.
</p>
<p>
    Because they run at the kernel-mode, kernel-mode rootkits have much more
    power over the system than rootkits that live at the
    process/program/application level. Detection is far more difficult, because
    detection programs themselves run at the process/program/application level
    and rely on the kernel to function.
</p>
<p>
In most operating systems, including UNIX and Windows, the    <strong><mark>kernel</strong></mark> is special software that controls various extremely
    important elements of the machine. The kernel sits between individual
    running programs and the hardware itself.
</p>
<p>
    A primary method for invading the Linux kernel to implement a kernel-mode
    rootkit involves creating an evil <strong><mark>loadable kernel module</strong></mark>
    that manipulates the existing kernel. This technique first emerged publicly
    in approximately 1997, and grew in popularity over subsequent years, with a
    huge variety of different evil module variations available today. Today, it
    remains the most popular technique for implementing kernel-mode rootkits on
    Linux systems.
</p>
<p>
    Loadable kernel modules run in kernel mode, and can augment or even replace
    existing kernel features, all without a system reboot. Because of the
    convenience of this feature for injecting new code into the kernel,
    it&#8217;s one of the easiest methods for implementing kernel-mode rootkits
    on systems that support kernel modules (such as Linux and Solaris).
</p>
<p>
    Similarly, by creating <strong><mark>malicious device drivers</strong></mark>, an
    attacker can undermine the Windows kernel. Device drivers run at kernel
    mode, and have been used to implement Windows kernel-mode roolkits by
    altering the system call table. Starting with Windows Vista (and following
    with Windows 7, Windows 2000, and Windows 8), Microsoft required mandatory
    device driver signing for Windows kernel components.
</p>
<p>
    There are ways to subvert this process, however. One way is to steal
    legitimate private keys issued by Microsoft. This technique was used in the
    Stuxnet which relied on stolen signing keys issued to two legitimate
    companies. Alternatively, mandatory device driver signing could be bypassed
    using method 2 for altering the kernel: manipulating memory.
</p>
<p>
    With root-level permissions on the box, the attacker could just replace or
    patch the kernel image file on the hard drive itself. That way, upon the
    next reboot of the system, the attacker&#8217;s evil kernel would be
    reloaded into the system instead of the original wholesome kernel. In the
    Linux file system, the kernel image is stored in a file called
    &#8220;vmlinuz,&#8221; typically located in the /boot directory.
</p>
<p>
    Another kernel-mode rootkit alternative involves the bad guy breaking into
    the machine with root privileges and making the existing operating system a
    guest inside a <strong><mark>virtual machine environment</strong></mark>. Then, after
    starting this virtual machine containing the original system, the attacker
    runs underneath with his or her own hypervisor, controlling the system
    underneath the kernel of the guest operating system.
</p>
<p>
    Hardening your systems to prevent superuser compromise is a critical first
    step. Microsoft ships Windows with a variety of security template files for
    workstations, servers, and domain controllers. However, these built-in
    security templates tend to be either way too weak so that any attacker can
    slice through them, or so strong that they render the system unusable in a
    real-world environment.
</p>
<p>
    <strong><mark>System hardening templates</strong></mark>
    , available at http://www.cisecurity.org. These templates apply to Windows,
    Linux, Solaris, HP-UX, Cisco Routers, and Oracle Databases, as well as
    numerous other types of platforms (Microsoft Exchange Server, Microsoft SQL
    Server, Apache, BIND, Novell eDirectory, etc.). They serve as an excellent
    starting and reference point for your security configuration. You can tweak
    them to make them stronger or loosen their restrictions for your
    environment.
</p>
<p>
    The Center for Internet Security has also released free scoring tools, so
    you can check to see how well your security settings match a given
    template, such as the Win2K Pro Gold Template. You run scoring tools on a
    local system to compare your security stance to a baseline template, giving
    you a summary score between 0 and 10. The higher your score, the more
    closely you match the template used for comparison.
</p>
<p>
    There are several other tools that provide similar functionality to Rootkit
    Revealer. These tools all ask the system a series of questions, looking for
    discrepancies in the answers that could be a sign of a rootkit. Several of
    the tools have been released by antivirus vendors. An incident handler
    should consider carrying several of these tools on a USB to get multiple
    opinions of whether a rootkit might be present on a machine under
    investigation.
</p>
<p>
    Although they can be tricked by very thorough kernel-mode rootkits, you
    should still use file integrity checking tools, such as the Tripwire,
    OSSEC, AIDE, and the related programs. However, a less careful attacker
    might forget to configure the kernel-mode rootkit to hide alterations to
    one or two sensitive system files. Even a single mistake in the file-hiding
    configuration of the kernel-mode rootkit by the bad guys could expose them
    to detection by your file integrity checker.
</p>
<p>
Increasingly, people are turning to    <strong><mark>network-based detection</strong></mark> and defensive tools, in the form
    of network forensics applications that pull data from lots of systems and
    correlate events to determine what&#8217;s actually going on. By looking
    for unusual network behavior caused by malware infections, security
    personnel have a better shot at detecting the pathogenic code.
</p>
<p>
    One of the most common methods for <strong><mark>hiding files</strong></mark> on a UNIX
    system is to simply give the file a name that starts with a dot. Attackers
    will disguise files and directories by naming them dot-space,
    dot-dot-space, dot-dot-dot, or even just space. This isn&#8217;t terribly
    sophisticated, but it works well in a pinch! Just name a file
    dot-dot-space, and many administrators won&#8217;t even notice the file.
    Essentially, the file is camouflaged, so that an unobservant user or
    administrator will not notice it as the redundant dots flash by on the
    screen.
</p>
<p>
    Attackers frequently hide data inside /dev, /tmp, and /etc. The /dev
    directory contains information about devices on the system, such as chunks
    of your hard drive and references to terminals. It&#8217;s full of
    thousands of items and is therefore a good place to sneak additional files
    into.
</p>
<p>
    After an attacker takes over a system, he usually wants to alter the system
    logs to erase the entries associated with the techniques he used to gain
    access to the system. Some attackers will just clean the logs out entirely,
    deleting everything from the <strong><mark>log file</strong></mark>. Such a technique is
    quite noticeable by the administrators, however. Therefore, more
    sophisticated attackers will delete selected entries from the log files.
    Only entries associated with the attackers gaining access, such as
    incorrect logins or process crashing, will be removed.
</p>
<p>
    Whenever you type a command in a UNIX shell, the shell has the option (if
    it is configured appropriately) of recording each command. By default, the
    Bash shell included in Linux stores the most recent commands typed in. The
    default history file size is 500 commands in bash, although some Linux
    distros increase this to 1000 (including RedHat). An investigator can,
    therefore, look in the bash history file for a user to see what that user
    has typed recently. Bad guys don&#8217;t want the investigators to see what
    happened, so they will often edit the bash history file, which is written
    in plain ASCII. A particularly nasty attacker might plant false commands
    into another user&#8217;s history file to divert attention during an
    investigation.
</p>
<p>
UNIX systems have four files better known as the    <strong><mark>accounting entries</strong></mark>. The utmp file stores information about
    all users currently logged into the system. This file is consulted by the
    &#8220;who&#8221; command to print a list of users with actively logged in
    sessions on the system. The wtmp file stores information about all users
    who have ever logged into the machine. The btmp file stores information
    about bad login attempts (i.e., failures to properly authenticate). The
    lastlog file shows information associated with the most recent login time
    and date for each user. This file is consulted by the login program when
    each user logs into the system to display the last login date and time for
    the user. Attackers want to modify these files so system administrators
    can&#8217;t tell what they&#8217;re up to.
</p>
<p>
    The Windows NT File System (NTFS) supports a feature known as &#8220;file
    streaming.&#8221; <strong><mark>File streaming</strong></mark> applies only to NTFS
    partitions. An attacker can create additional streams associated with any
    file or directory name on the system. The attacker can then use these
    streams to hide his or her sensitive information, such as attack tools or
    sniffer logs. Any file or directory on an NTFS partition can be used to
    hide stich information, such as Notepad or Word.
</p>
<p>
    To detect malicious software hidden in a file stream, you must make sure to
    use an updated antivirus tool. Over the last couple of years, most major
    antivirus manufacturers have included the ability to search through file
    streams to find malicious software.
</p>
<p>
    In Windows, <strong><mark>system logs</strong></mark> are generated by the Event Logger
    service. The Windows Event Logger produces a set of buffer files (called
    .LOG files). The three primary Windows event types are stored temporarily
    in these log files: &#8226; SYSTEM.LOG &#8226; SECURITY.LOG &#8226;
    APPLICATION.LOG
</p>
<p>
    To erase traces of activity, a perpetrator would at a minimum have to edit
    SECEVENT.EVT, but to be more confident that all traces of the
    perpetrator&#8217;s activity are gone, the attacker would possibly want to
    edit the other log files as well.
</p>
<p>
    If the attacker has physical access to the Windows system, he or she could
    boot the system from a Linux floppy disk. With a specialized editing tool,
    the attacker would then be able to access the log files on the NTFS
    partition and delete elements from them. Because Windows is not running,
    the file is no longer write-protected.
</p>
<p>
    A similar idea has been implemented in a password-resetting tool for
    Windows. This tool consists of a Linux boot disk that allows an attacker to
    edit the SAM database on a Windows system. The attacker can change the
    administrator password, resetting it to any value the attacker desires.
</p>
<p>
    One of the most obvious and effective ways to defend your logs is to employ
    a <strong><mark>separate logging server</strong></mark>. If the system logs are sent to
    a remote system, the attacker will not be able to edit them on the machine
    that he or she has just taken over. Instead, after taking over one system,
    he or she will have to mount another successful attack against your logging
    server. Because your logging server can be dedicated to just gathering
    system logs, it can be very carefully secured. In UNIX, the syslog process
    can be easily configured to send its logs to a remote host. In addition to
    sending the logs to a remote logging server, you can also generate a
    cryptographic integrity check of the log files to protect them.
</p>
<p>
    One of the most common ways to hide information as it is transmitted across
a network is to use a technique called &#8220;tunneling.&#8221; With    <strong><mark>tunneling</strong></mark>, one protocol is carried inside another
    protocol. For example, you can carry shell commands inside web traffic.
    Alternatively, you can carry shell traffic inside ICMP packets. You
</p>
<p>
    Instead of carrying data via HTTP traffic, some attackers opt for other
    protocols. Numerous tools are readily available to carry traffic via covert
    channels using ICMP packets. Many networks allow outbound ICMP Echo packets
    and their associated responses, making ping packets a useful way to tunnel
    traffic in a covert fashion.
</p>
<p>
    Although <strong><mark>covert channels</strong></mark> created by embedding one protocol
    entirely in a different protocol can be quite effective, covert channels
    can also be constructed by inserting data into unused or misused fields of
    protocol headers themselves. The TCP/IP protocol suite is particularly
    useful in carrying covert channels. Many of the fields in the TCP and IP
    headers have vast openings through which data can be sent. One particularly
    interesting tool that illustrates exploiting TCP/IP headers to create
    covert channels is called &#8220;Covert TCP.&#8221;
</p>
<p>
    The defenses for Covert_TCP involve keeping the attackers off your systems
    by applying the principle of least privileges and stopping unknown
    processes from running on your machines. Also, employ network-based
    intrusion detection systems to look for anomalous behavior in the traffic.
</p>
<p>
    If an attacker is using covert channels on your machines, you should scour
    other related systems looking for the same program. The system should be
    rebuilt if the attacker compromised root or admin-level accounts on the
    box.
</p>
<p>
    <strong><mark>Steganography</strong></mark>
    involves hiding data within a file, such as an image or sound file, so that
    the meaning of the message and the fact that a message is being sent, is
    concealed. There are numerous methods allowing data to be embedded in a
    wide range of file types.
</p>
<p>
    Detecting the presence of hidden data is quite trivial if you have the
    original source image. You can simply compare the two files and see whether
    they are different using a simple duff program. In most cases, however, you
    will not have the source image and will not be able to do this.
</p>
<p>
    We are seeing many attacks against client-side software, such as browsers,
    music players, image viewing tools, etc. This will continue to be a
    dominant vector for some time. Also, as more features and power are added
    to smaller platforms like cell phones and PDAs, attackers will likely
    increasingly target these types of tools.
</p>
<p>
    If attackers are able to manipulate infrastructure routing, they can steal
    massive amounts of data or shut down the Internet entirely. If they find a
    flaw in the Border Gateway Protocol (BGP4), they could cause major
    disruptions. Similarly, the domain name system underlies so much of
    Internet functionality. If attackers discover a major flaw in DNS systems,
    they can manipulate DNS to conduct numerous types of attacks.
</p>


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
    if (mySidebar.style.display === 'block') {
        mySidebar.style.display = 'none';
        overlayBg.style.display = "none";
    } else {
        mySidebar.style.display = 'block';
        overlayBg.style.display = "block";
    }
}

// Close the sidebar with the close button
function w3_close() {
    mySidebar.style.display = "none";
    overlayBg.style.display = "none";
}
</script>

</body>
</html>
